import java.util.concurrent.TimeUnit;

// This build.gradle is released along with gradle wrapper inside a system tests
// zip, such that the user of the zip may use gradle to compile and run system
// tests against a given version of WRES. The goal is to follow the "build your
// binaries once" from a given commit. The goal is also to allow developers to
// run these tests locally when they have the entire source tree available.
// There is intentionally no main java source code, it is all tests. The reason
// for putting it under "test" is to align with tools that expect tests to be
// under "test", such as junit or jacoco under gradle.

// In order to get the test framework software (e.g. junit):
repositories
{
    mavenCentral()
}

apply plugin: 'java'

// The default value of the versionToTest will be picked up from
// gradle.properties file. versionToTest can be overridden at gradle run time
// by using -PversionToTest=[version] on the gradle command line. The same is
// true for wresZipDirectory, which is the directory to find the zip ein.

// This task takes the software under test (a wres zip) and extracts it
task( unzipArtifactToTest, type: Copy, group: 'test' )
{
    description = 'Unzips the wres zip artifact to be tested.'

    def zipFile = file( "${wresZipDirectory}/wres-${versionToTest}.zip" )
    def outputDir = file( "${buildDir}" )

    println( "buildDir: ${buildDir}" )
    println( "wresZipDirectory: " + wresZipDirectory )
    println( "zipFile: " + zipFile )
    println( "outputDir: " + outputDir )

    from zipTree(zipFile)
    into outputDir
}

// To compile the test java code, we need the artifact libs
compileTestJava.dependsOn( unzipArtifactToTest )

// This task unzips a graphics client artifact, after the main artifact has been unzipped
task( unzipGraphicsArtifactToTest, dependsOn: unzipArtifactToTest, type: Copy, group: 'test' )
{
    description = 'Unzips the wres graphics zip artifact to be tested.'

    def zipFile = file( "${wresGraphicsZipDirectory}/wres-vis-${graphicsVersionToTest}.zip" )
    
    def outputDir = file( "${buildDir}" )

    println( "wresGraphicsZipDirectory: " + wresZipDirectory )
    println( "graphicsZipFile: " + zipFile )
    println( "outputDir: " + outputDir )

    from zipTree(zipFile)
    into outputDir
}

// The graphics process to destroy on completion of the test task
Process graphicsProcess = null;

// This task starts a graphics client
task( startGraphicsClient, dependsOn: unzipGraphicsArtifactToTest, group: 'test' )
{
    def graphicsBin = "${buildDir}/wres-vis-${graphicsVersionToTest}/bin/wres-vis"
 
    if( isWindows() )
    {
       graphicsBin = graphicsBin + ".bat"
    }

    doLast
    {
        // Pass on any java options
        def testJvmPropertiesRaw = project.properties['testJvmSystemProperties']

        ProcessBuilder pb = new ProcessBuilder( graphicsBin );
        pb.environment()
          .put( "JAVA_OPTS", testJvmPropertiesRaw );

        println( "Starting graphics client ${graphicsVersionToTest}..." )
        
        // Redirect output to a log file
        File logFile = new File( project.buildDir, "wres-graphics-${graphicsVersionToTest}.log" )
        graphicsProcess = pb.redirectErrorStream( true )
                            .redirectInput( ProcessBuilder.Redirect.INHERIT )
                            .redirectOutput( ProcessBuilder.Redirect.to( logFile ) )
                            .start();
        // Do not wait for the graphics client to end
        println( "Graphics client has started." )
    }
}

// This task stops a graphics client
task( stopGraphicsClient, group: 'test' )
{
    doLast
    {
        if( graphicsProcess != null )
        {
            println( "Stopping graphics client ${graphicsVersionToTest}." )

            // Destroy the children and then the parent
            for( nextChild in graphicsProcess.children() )
            {
                nextChild.destroy()
            }
            graphicsProcess.destroy()            
            graphicsProcess.waitFor( 5, TimeUnit.SECONDS )
            
            // Still alive? Mdk
            if( graphicsProcess.isAlive() )
            {
                for( nextChild in graphicsProcess.children() )
                {
                    nextChild.destroyForcibly()
                }
                graphicsProcess.destroyForcibly()
            }
        }
    }
}

// Start the graphics client before all tests
test.dependsOn( startGraphicsClient )

// Stop the graphics client after all tests
test.finalizedBy( stopGraphicsClient )

// Windows OS?
boolean isWindows()
{
    return System.properties['os.name'].toLowerCase().contains( 'windows' );
}

dependencies
{
    testCompile 'commons-io:commons-io:2.6'
    testCompile 'com.google.guava:guava-testlib:21.0'
    testCompile 'com.google.guava:guava:22.0'
    testCompile 'junit:junit:4.12'
    testCompile 'org.mockito:mockito-core:2.8.47'
    testCompile 'org.slf4j:slf4j-api:1.8.0-beta2'

    // Expose all wres contents here, using unzipArtifactToTest task.
    // Use of fileTree is important, lazily evaluated, meaning that the contents
    // from the unzipArtifactToTest task will be here by now
    testCompile fileTree( dir: "${unzipArtifactToTest.destinationDir}/wres-${versionToTest}",
                          include: '**/*.jar' )

    // Add the lib/conf directory to testRuntime classpath like actual WRES does
    testRuntime files( "${unzipArtifactToTest.destinationDir}/wres-${versionToTest}/lib/conf" )

    println( "buildDir: ${buildDir}" )
    println( "versionToTest: ${versionToTest}" )
    println( "unzipArtifactToTest.destinationDir: " + unzipArtifactToTest.destinationDir )
}

test
{
    // Jump through some hoops to allow caller to set test JVM system properties
    // in one variable, like this:
    // -PtestJvmSystemProperties="-Dwres.useSSL=false -Dwres.blah=true"
    // or like this:
    // -PtestJvmSystemProperties="wres.useSSL=false wres.blah=true"
	jvmArgs '-XX:+HeapDumpOnOutOfMemoryError'
	maxHeapSize = "2180m"
    // No longer necessary to fork on every test: see #61206
    // forkEvery=1
    def testJvmPropertiesRaw = project.properties['testJvmSystemProperties']
    def splittedTestJvmProperties = testJvmPropertiesRaw.trim().split( " " )
    println( "Test JVM System Properties split: ${splittedTestJvmProperties}" )
    def furtherSplittedTestJvmProperties = [:]

    // Without the findall, a seemingly empty array still evaluates the "each"
    splittedTestJvmProperties.findAll().each{ s ->
        def noDashD = s
        if ( s.startsWith( "-D" ) )
        {
            noDashD = s.substring( 2 )
        }
        def pair = noDashD.split( "=" )
        furtherSplittedTestJvmProperties[pair[0]] = pair[1]
    }

    systemProperties += [ "user.timezone": "UTC" ]
    println( "Test JVM System Properties to be applied: ${furtherSplittedTestJvmProperties}" )
    systemProperties += furtherSplittedTestJvmProperties
}
