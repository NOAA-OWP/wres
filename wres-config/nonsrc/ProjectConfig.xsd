<?xml version="1.0" encoding="UTF-8" ?>
<?xml-stylesheet type="text/xsl" href="xs3p.xsl"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:jaxb="http://java.sun.com/xml/ns/jaxb"
           jaxb:version="2.1"
           elementFormDefault="qualified">

    <xs:complexType name="doubleBoundsType">
        <xs:attribute name="minimum" type="xs:double" />
        <xs:attribute name="maximum" type="xs:double" />
        <xs:attribute name="default_minimum" type="xs:double" />
        <xs:attribute name="default_maximum" type="xs:double" />
    </xs:complexType>

    <xs:complexType name="intBoundsType">
        <xs:attribute name="minimum" type="xs:int" />
        <xs:attribute name="maximum" type="xs:int" />
    </xs:complexType>

    <xs:complexType name="durationBoundsType">
        <xs:attribute name="greaterThan" type="duration" />
        <xs:attribute name="lessThanOrEqualTo" type="duration" />
        <xs:attribute name="unit" type="durationUnit" default="hours" />
    </xs:complexType>

    <xs:complexType name="urlParameterType">
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="UrlParameter" />
            </xs:appinfo>
        </xs:annotation>
        <xs:all>
            <xs:element name="name" type="xs:string" />
            <xs:element name="value" type="xs:string" />
        </xs:all>
    </xs:complexType>

    <xs:simpleType name="datasourceType">
        <xs:annotation>
            <xs:documentation>
                Originally, this type was used to direct ingest data to either
                a set of "forecast" or "observation" tables in the database.
                See discussion in #57301 for making it optional or removing it
                altogether. It should become optional, but changes in #65216
                can change the purpose of this declaration to be used to direct
                treatment of the dataset after ingest, for example to treat AnA
                (analyses) differently from forecasts on retrieval. That is the
                reason for adding "analyses" here.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="ensemble forecasts" />
            <xs:enumeration value="single valued forecasts" />
            <xs:enumeration value="observations" />
            <xs:enumeration value="simulations" />
            <xs:enumeration value="analyses" />
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="leftOrRightOrBaseline">
        <xs:annotation>
            <xs:documentation>
                An enumerated position within a pairing.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="left" />
            <xs:enumeration value="right" />
            <xs:enumeration value="baseline" />
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="sourceTransformationType">
        <xs:annotation>
            <xs:documentation>This is only useful currently in one circumstance:
                where a persistence forecast is to serve as a "baseline" source. In
                that case, the "baseline" source should refer to a long time series,
                such as observations or simulations (i.e., the "left" source) with
                this flag specified as "persistence".
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="persistence" />
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="persistence">
        <xs:annotation>
            <xs:documentation>Creates a baseline by persisting the prescribed source
                forwards in time with a specified order or "lag", which must be 
                greater than or equal to zero. For non-forecast sources, the lag is
                applied to the valid time. For example, a lag of 1 means that the 
                persisted value is the value from the persistence source that is one 
                time step prior to the current valid time. For a forecast source, the 
                lag is applied to the forecast reference time, or the first reference 
                time if there are many. In this context, a lag of 3 means that the 
                persisted value at all forecast valid times is the value from the 
                persistence source that is 3 steps prior to the forecast reference 
                time.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:int" />
    </xs:simpleType>

    <xs:simpleType name="interfaceShortHand">
        <xs:annotation>
            <xs:documentation>
                The interface serves as a shorthand to tell WRES how to get a
                dataset from a particular URI. It can mean the API structure of
                a web service such as WRDS or NWIS, or it can mean the
                path/resource  structure of an NWM dataset. Whatever structure
                is on top of a URI that cannot be automatically discerned from
                the URI or data within that URI is summarized by one of these
                short-hands and must be specified. When an NWM forecast is
                specified, issuedDates must also be specified. When an interface
                serving observations is specified, dates must also be specified.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="wrds_ahps" />
            <xs:enumeration value="wrds_nwm" />
            <xs:enumeration value="usgs_nwis" />
            <xs:enumeration value="nwm_short_range_channel_rt_conus" />
            <xs:enumeration value="nwm_short_range_channel_rt_hawaii" />
            <xs:enumeration value="nwm_short_range_no_da_channel_rt_hawaii" />
            <xs:enumeration value="nwm_short_range_channel_rt_puertorico" />
            <xs:enumeration value="nwm_short_range_no_da_channel_rt_puertorico" />
            <xs:enumeration value="nwm_medium_range_ensemble_channel_rt_conus" />
            <xs:enumeration value="nwm_medium_range_deterministic_channel_rt_conus" />
            <xs:enumeration value="nwm_medium_range_ensemble_channel_rt_conus_hourly" />
            <xs:enumeration value="nwm_medium_range_deterministic_channel_rt_conus_hourly" />
            <xs:enumeration value="nwm_medium_range_no_da_deterministic_channel_rt_conus" />
            <xs:enumeration value="nwm_analysis_assim_channel_rt_conus" />
            <xs:enumeration value="nwm_analysis_assim_no_da_channel_rt_conus" />
            <xs:enumeration value="nwm_analysis_assim_extend_channel_rt_conus" />
            <xs:enumeration value="nwm_analysis_assim_extend_no_da_channel_rt_conus" />
            <xs:enumeration value="nwm_analysis_assim_channel_rt_hawaii" />
            <xs:enumeration value="nwm_analysis_assim_no_da_channel_rt_hawaii" />
            <xs:enumeration value="nwm_analysis_assim_channel_rt_puertorico" />
            <xs:enumeration value="nwm_analysis_assim_no_da_channel_rt_puertorico" />
            <xs:enumeration value="nwm_long_range_channel_rt_conus" />
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="ensembleCondition">
        <xs:annotation>
            <xs:documentation>The ensemble element can be used to restrict
                evaluation based upon ensemble trace names in the dataset. This
                currently is only compatible with PI-XML and NWM sources. For
                example, you can restrict evaluation to a single trace with the
                name attribute: the contents of either ensembleMemberId or
                ensembleMemberIndex for PI-XML, the zero-based integer index of
                the ensemble trace for NWM (and sources with no trace names). If
                the exclude flag is set to true, then the settings actually specify
                time series to exclude; otherwise it specifies times series to
                include.
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="label" type="xs:string" />
        <xs:attribute name="name" type="xs:string" />

        <!-- member_id is deprecated, ignored by WRES! Do not use! -->
        <xs:attribute name="member_id" type="xs:string" />

        <!-- qualifier is deprecated, ignored by WRES! Do not use! -->
        <xs:attribute name="qualifier" type="xs:string" />

        <xs:attribute name="exclude" type="xs:boolean" default="false" />
    </xs:complexType>

    <xs:complexType name="feature">
        <xs:annotation>
            <xs:documentation>Declaration of features to pair. The name of the
                feature on the left, as it exists in the left dataset, goes in
                the "left" attribute. The name of the feature on the right, as
                it exists in the right dataset, goes in the "right" attribute.
                The name in a dataset may be an arbitrary name (e.g. from CSV),
                it may be an NWS LID (e.g. from AHPS), it may be a USGS site
                code (e.g. from NWIS), it may be an NWM feature id (e.g. from
                WRDS). When left="X" and right="Y" is declared, it means "pair
                data from left that the left calls feature X with data from
                right that the right calls feature Y."
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="left" type="xs:string" />
        <xs:attribute name="right" type="xs:string" />
        <xs:attribute name="baseline" type="xs:string" />
    </xs:complexType>

    <xs:complexType name="unnamedFeature">
        <xs:annotation>
            <xs:documentation>
            </xs:documentation>
        </xs:annotation>
        <xs:all>
            <xs:element name="coordinate" type="coordinateSelection" minOccurs="0" />
            <xs:element name="polygon" type="PolygonSelection" minOccurs="0"/>
            <xs:element name="circle" type="CircleSelection" minOccurs="0" />
        </xs:all>
    </xs:complexType>

    <xs:complexType name="featurePool">
        <xs:annotation>
            <xs:documentation>Used to declare groups of features for pooling. This is
                an EXPERIMENTAL FEATURE that is protected by a feature toggle. Unless 
                you are a developer, do not use!
            </xs:documentation>
            <xs:appinfo>
                <jaxb:class name="FeaturePool" />
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="feature" type="feature" minOccurs="1" maxOccurs="unbounded" >
            </xs:element>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" />
    </xs:complexType>

    <xs:complexType name="coordinateSelection">
        <xs:all>
            <xs:element name="longitude" type="xs:float" />
            <xs:element name="latitude" type="xs:float" />
            <xs:element name="range" type="xs:float" />
        </xs:all>
    </xs:complexType>

    <xs:complexType name="CircleSelection">
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="Circle" />
            </xs:appinfo>
        </xs:annotation>
        <xs:all>
            <xs:element name="latitude" type="xs:float" />
            <xs:element name="longitude" type="xs:float" />
            <xs:element name="diameter" type="xs:float" />
        </xs:all>
        <xs:attribute name="srid" type="xs:integer" default="4326" />
    </xs:complexType>

    <xs:complexType name="PolygonSelection">
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="Polygon" />
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="point" minOccurs="3" maxOccurs="unbounded" >
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="latitude" type="xs:float" />
                        <xs:element name="longitude" type="xs:float" />
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="srid" type="xs:integer" default="4326" />
    </xs:complexType>

    <xs:simpleType name="featureDimension">
        <xs:restriction base="xs:string">
            <xs:enumeration value="nws_lid" />
            <xs:enumeration value="usgs_site_code" />
            <xs:enumeration value="nwm_feature_id" />
            <xs:enumeration value="custom" />
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="unitAlias">
        <xs:annotation>
            <xs:documentation>Declares that the value for "alias" should be
                interpreted as the value for "unit" by the software. The "unit"
                should be parseable by the indriya measurement units library.
                For example, 'mm/s' is parseable but 'millimeters per second' is
                not. To treat 'millimeters per second' as 'mm/s' set alias to
                the former and unit to the latter.
            </xs:documentation>
        </xs:annotation>
        <xs:all>
            <xs:element name="alias" type="xs:string" />
            <xs:element name="unit" type="xs:string" />
        </xs:all>
    </xs:complexType>

    <xs:complexType name="datasource">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="DataSourceConfig" />
            </xs:appinfo>
            <xs:documentation>Provides information necessary for WRES to load
                data from various sources.
            </xs:documentation>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="type" type="datasourceType" />

            <xs:element name="source" minOccurs="1" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>Provides details about the source of the data.
                        The text value of the element specifies an individual file to read
                        (full path); a directory to process (it is scanned recursively and
                        all files read unless the pattern is set; see below); or a URL (if
                        the format is an API).
                    </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:anyURI">

                            <xs:attribute name="interface" type="interfaceShortHand">
                                <xs:annotation>
                                    <xs:documentation>
                                        Specifies the interface short-hand.
                                        See available interfaceLabel types. This
                                        is required for sources that are not
                                        simple, i.e. sources that do not enclose
                                        each timeseries within a bytestream or
                                        require some API or interface knowledge.
                                        Example simple sources include PI-XML
                                        or datacard datasets. Example sources
                                        that require this short-hand include the
                                        NWM sources, WRDS, and USGS NWIS. WRES
                                        combines knowledge of the service or
                                        layout with the date ranges specified in
                                        the project declaration to automatically
                                        read the data source.
                                    </xs:documentation>
                                </xs:annotation>
                            </xs:attribute>

                            <xs:attribute name="zoneOffset" type="xs:string">
                                <xs:annotation>
                                    <xs:documentation>Specifies the time zone offset for the data.
                                        This is required for the datacard format, which does not
                                        include time zone information in the file. For example,
                                        datacard data from ABRFC may including a zoneOffset of "CST".
                                        It should be unnecessary for most/all other formats.
                                    </xs:documentation>
                                </xs:annotation>
                            </xs:attribute>

                            <!-- missingValue may have multiple comma delimited values like "-999,
                                -996" -->
                            <xs:attribute name="missingValue" type="xs:string" default="-999.0">
                                <xs:annotation>
                                    <xs:documentation>Specifies the values to treat as missing. It
                                        is a comma delimited list of numbers. For example,
                                        "-9999.0,-999.0,-998.0" would mean -998, -999, and -9999 are
                                        all treated as missing values.
                                    </xs:documentation>
                                </xs:annotation>
                            </xs:attribute>

                            <xs:attribute name="pattern" type="xs:string" default="">
                                <xs:annotation>
                                    <xs:documentation>Uses GLOB notation,
                                        https://en.wikipedia.org/wiki/Glob_(programming), to specify a
                                        pattern that restricts files read to only those matching the
                                        pattern. For example, "**/*.xml" will match any XML file. Note
                                        that the "**/" at the beginning is required.
                                    </xs:documentation>
                                </xs:annotation>
                            </xs:attribute>

                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="variable" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:annotation>
                        <xs:documentation>Declares the variable to be evaluated
                            within the declared dataset. The variable name is
                            also known as a physical element code.
                        </xs:documentation>
                    </xs:annotation>
                    <xs:simpleContent>
                        <xs:extension base="xs:string">
                            <xs:attribute name="label" type="xs:string" />
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="transformation" type="sourceTransformationType" minOccurs="0" maxOccurs="1" />
            <xs:element name="persistence" type="persistence" minOccurs="0" maxOccurs="1" />
            <xs:element name="ensemble" type="ensembleCondition" minOccurs="0" maxOccurs="unbounded" />
            <xs:element name="timeShift" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:annotation>
                        <xs:documentation>Can be used to manually time-shift the data read 
                            from the source prior to data ingest. For example, with width set
                            to "-2" and a unit set to "hours", the data will have all times read
                            in adjusted by -2 hours.
                        </xs:documentation>
                    </xs:annotation>
                    <xs:all>
                        <xs:element name="width" type="duration" />
                        <xs:element name="unit" type="durationUnit" />
                    </xs:all>
                </xs:complexType>
            </xs:element>
            <xs:element name="existingTimeScale" type="timeScale" minOccurs="0" maxOccurs="1"/>
            <xs:element name="urlParameter" type="urlParameterType" minOccurs="0" maxOccurs="unbounded" />
            <!-- This option is marked deprecated for removal as of WRES version 5.12. See #93972. -->
            <xs:element name="removeMemberByValidYear" type="removeMemberByValidYear" minOccurs="0" maxOccurs="1"/>
        </xs:sequence>
        <xs:attribute name="label" type="xs:string" />
        <xs:attribute name="featureDimension" type="featureDimension" />
    </xs:complexType>

    <xs:complexType name ="removeMemberByValidYear">
           <xs:annotation>
                <xs:documentation>If present, remove the ensemble member whose
                    label matches the valid year of the event for a year that 
                    begins on the prescribed monthday. When the monthday is 
                    undefined, it defaults to 1 January.</xs:documentation>
               </xs:annotation>
        <xs:attribute name="earliestDay" type="xs:short" default = "1" />
        <xs:attribute name="earliestMonth" type="xs:short" default = "1" />
    </xs:complexType>

    <xs:simpleType name="thresholdFormat">
        <xs:restriction base="xs:string">
            <xs:enumeration value="csv" />
            <xs:enumeration value="wrds" />
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="datasourceBaseline">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="DataSourceBaselineConfig" />
            </xs:appinfo>
            <xs:documentation>Provides information necessary for WRES to load 
                data from baseline data sources. When declaring separateMetrics 
                as "true", all possible metrics will be computed for the baseline 
                pairs, as well as the right pairs. All possible metrics include 
                skill scores that have a default baseline, such as climatology. 
                For skill scores that do not have a default baseline, such as 
                the continuous ranked probability skill score, statistics will 
                only be computed for the pairs of left and right values, not 
                for the pairs of left and baseline values.
            </xs:documentation>
        </xs:annotation>

        <xs:complexContent>
            <xs:extension base="datasource">
                <xs:attribute name="separateMetrics" type="xs:boolean" default="false" />
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!-- An enum to specify the scope of the thresholds when filtering paired data. -->
    <xs:simpleType name="thresholdDataType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="left" />
            <xs:enumeration value="right" />
            <xs:enumeration value="left and right" />
            <xs:enumeration value="any right" />
            <xs:enumeration value="left and any right" />
            <xs:enumeration value="right mean" />
            <xs:enumeration value="left and right mean" />
        </xs:restriction>
    </xs:simpleType>

    <!-- An enum to specify if a threshold is a probability or real value. -->
    <xs:simpleType name="thresholdType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="probability" />
            <xs:enumeration value="value" />
	    <xs:enumeration value="probability classifier" />
        </xs:restriction>
    </xs:simpleType>

    <!-- Thresholds need to specify an operator suitable for thresholding -->
    <xs:simpleType name="thresholdOperator">
        <xs:restriction base="xs:string">
            <xs:enumeration value="equal to" />
            <xs:enumeration value="less than" />
            <xs:enumeration value="less than or equal to" />
            <xs:enumeration value="greater than" />
            <xs:enumeration value="greater than or equal to" />
        </xs:restriction>
    </xs:simpleType>

    <!-- Container for thresholds. -->
    <xs:complexType name="thresholds">

        <!-- for class naming using xjc -->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="ThresholdsConfig" />
            </xs:appinfo>
        </xs:annotation>

        <!-- A threshold contains a type, applyTo and operator and EITHER an external source OR an internal commaSeparatedValues. -->
        <xs:sequence>
	    <xs:element name="type" type="thresholdType" default="probability" minOccurs="0" maxOccurs="1"/>
            <xs:element name="applyTo" type="thresholdDataType" minOccurs="0" maxOccurs="1"/>
            <!-- Choice of using an internal source or an external source -->
            <xs:choice>
                <!-- Internal source -->
                <xs:element name="commaSeparatedValues" type="xs:string" default="0.05,0.1,0.25,0.50,0.75,0.90,0.95" minOccurs = "1"/>
                <!-- External source -->
                <xs:element name="source" minOccurs="1">
                    <xs:complexType>
                        <xs:simpleContent>
                            <xs:extension base="xs:anyURI">
                                <xs:attribute name="format" type="thresholdFormat" use="required" />
                                <xs:attribute name="unit" type="xs:string" default="" />
                                <xs:attribute name="missingValue" type="xs:string" default="-999.0" />
                                <xs:attribute name="provider" type="xs:string" />
                                <xs:attribute name="ratingProvider" type="xs:string" />
                                <xs:attribute name="parameterToMeasure" type="xs:string" />
                                <xs:attribute name="featureNameFrom" type="leftOrRightOrBaseline" default="left" />
                            </xs:extension>
                        </xs:simpleContent>
                    </xs:complexType>
                </xs:element>
            </xs:choice>
            <xs:element name="operator" type="thresholdOperator" default="greater than" minOccurs="0" maxOccurs="1" />
        </xs:sequence>
    </xs:complexType>

    <!-- There is a mapping between these names and the enum in MetricConstants.
         For now, these two lists must be periodically synchronized manually.-->
    <xs:simpleType name="metricConfigName">
        <xs:restriction base="xs:string">

            <!-- When user wishes to have all the metrics that are valid for a
                 given configuration -->
            <xs:enumeration value="all valid" />

            <xs:enumeration value="bias fraction" />
            <xs:enumeration value="box plot of errors" />
            <xs:enumeration value="box plot of percentage errors" />
            <xs:enumeration value="box plot of errors by observed value" />
            <xs:enumeration value="box plot of errors by forecast value" />
            <xs:enumeration value="brier score" />
            <xs:enumeration value="brier skill score" />
            <xs:enumeration value="coefficient of determination" />
            <xs:enumeration value="contingency table" />
            <xs:enumeration value="pearson correlation coefficient" />
            <xs:enumeration value="continuous ranked probability score" />
            <xs:enumeration value="continuous ranked probability skill score" />
            <xs:enumeration value="threat score" />
            <xs:enumeration value="equitable threat score" />
            <xs:enumeration value="ensemble quantile quantile diagram" />
            <xs:enumeration value="frequency bias" />
            <xs:enumeration value="index of agreement" />
            <xs:enumeration value="kling gupta efficiency" />
            <xs:enumeration value="maximum" />
            <xs:enumeration value="mean absolute error" />
            <xs:enumeration value="mean" />
            <xs:enumeration value="mean error" />
            <xs:enumeration value="mean square error" />
            <xs:enumeration value="mean square error skill score" />
            <xs:enumeration value="mean square error skill score normalized" />
            <xs:enumeration value="median error" />
            <xs:enumeration value="minimum" />
            <xs:enumeration value="peirce skill score" />
            <xs:enumeration value="probability of detection" />
            <xs:enumeration value="probability of false detection" />
            <xs:enumeration value="quantile quantile diagram" />
            <xs:enumeration value="rank histogram" />
            <xs:enumeration value="relative operating characteristic diagram" />
            <xs:enumeration value="relative operating characteristic score" />
            <xs:enumeration value="reliability diagram" />
            <xs:enumeration value="root mean square error" />
            <xs:enumeration value="root mean square error normalized" />
            <xs:enumeration value="sample size" />
            <xs:enumeration value="sum of square error" />
            <xs:enumeration value="standard deviation" />
            <xs:enumeration value="volumetric efficiency" />
        </xs:restriction>
    </xs:simpleType>

    <!-- There is a mapping between these names and the enum in MetricConstants.
         For now, these two lists must be periodically synchronized manually.-->
    <xs:simpleType name="timeSeriesMetricConfigName">
        <xs:restriction base="xs:string">

            <!-- When user wishes to have all the metrics that are valid for a
                 given configuration -->
            <xs:enumeration value="all valid" />

	    <xs:enumeration value="time to peak error" />
            <xs:enumeration value="time to peak relative error" />
        </xs:restriction>
    </xs:simpleType>

    <!-- An enumeration of summary statistics associated with a metric -->
    <xs:simpleType name="summaryStatisticsName">
        <xs:restriction base="xs:string">
            <!-- Allows for all summary statistics -->
            <xs:enumeration value="all valid" />

            <xs:enumeration value="mean" />
            <xs:enumeration value="median" />
            <xs:enumeration value="minimum" />
            <xs:enumeration value="maximum" />
            <xs:enumeration value="standard deviation" />
            <xs:enumeration value="mean absolute" />
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="summaryStatistics">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="SummaryStatisticsConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="name" type="summaryStatisticsName" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <!-- Base type for a metric -->
    <xs:complexType name="abstractMetric" abstract="true">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="AbstractMetricConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:attribute name="label" type="xs:string" />
    </xs:complexType>

    <!-- Ordinary metrics -->
    <xs:complexType name="metric">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="MetricConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:complexContent>
            <xs:extension base="abstractMetric">
                <xs:all>
                    <xs:element name="name" type="metricConfigName" />
                </xs:all>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!-- Metrics that consume time-series and may have summary statistics associated with them -->
    <xs:complexType name="timeSeriesMetric">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="TimeSeriesMetricConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:complexContent>
            <xs:extension base="abstractMetric">
                <xs:all>
                    <xs:element name="name" type="timeSeriesMetricConfigName" />
                    <xs:element name="summaryStatistics" type="summaryStatistics" minOccurs="0" maxOccurs="1"/>
                </xs:all>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:simpleType name="destinationType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="csv" />
            <xs:enumeration value="csv2" />
            <xs:enumeration value="png" />
            <xs:enumeration value="svg" />
            <xs:enumeration value="netcdf" />
            <xs:enumeration value="netcdf2" />
            <xs:enumeration value="numeric" />
            <xs:enumeration value="graphic" />
            <xs:enumeration value="pairs" />
            <xs:enumeration value="protobuf" />
        </xs:restriction>
    </xs:simpleType>

    <!-- Possibilities for the outputType element. The "default" option indicates
    that the default output configuration should be used when multiple options are 
    possible for the same type of output data. The default should also be assumed 
    when the output type is undefined.-->
    <xs:simpleType name="outputTypeSelection">
        <xs:restriction base="xs:string">
            <xs:enumeration value="default" />
            <xs:enumeration value="lead threshold" />
            <xs:enumeration value="threshold lead" />
            <xs:enumeration value="single valued pairs" />
        </xs:restriction>
    </xs:simpleType>
    
    <!-- Element to store options related to generating graphics. -->
    <xs:complexType name="graphicalType">

        <xs:sequence>
            <!-- Specifies the override chart drawing parameters.  Will be processed as a String and passed to 
            charting tool so it can parse it.  Hence, the reason it is skipped. -->
            <xs:element name="config" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:any processContents="skip" namespace="##any" minOccurs="0" maxOccurs="unbounded" />
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <!-- Allow for metrics to be suppressed for this format -->
            <xs:sequence>
                <xs:element name="suppressMetric" type="metricConfigName" minOccurs="0" maxOccurs="unbounded" />
            </xs:sequence>
        </xs:sequence>

        <!-- Image width. -->
        <xs:attribute name="width" type="xs:int" />
        
        <!-- Image height. -->
        <xs:attribute name="height" type="xs:int" />
        
        <!-- Location of the template file.  Every plot type has a default file.
        This allows for using a user customized file.  When searching for the 
        file it will begin by loading it as a system resource from the lib/conf
        directory and, if it is not found, then as a file on the file system. -->
        <xs:attribute name="template" type="xs:string" />
    </xs:complexType>

    <!-- Element to store options related to generating Netcdf output -->
    <xs:complexType name="netcdfType">
        <xs:all>
            <!-- Specifies the path to a template. Eventually, we'll want to
            create one from the input files if one isn't supplied -->
            <xs:element type="xs:string" name="templatePath" minOccurs="0"  />
        </xs:all>
        <!-- Dictates the name of the variable to use for vector coordinates -->
        <xs:attribute type="xs:string" name="vectorVariable" default="lid" />

        <!-- Dictates the name of the variable that contains the y coordinates for gridded data -->
        <xs:attribute type="xs:string" name="gridYVariable" default="y" />

        <!-- Dictates the name of the variable that contains the x coordinates for the gridded data -->
        <xs:attribute type="xs:string" name="gridXVariable" default="x" />

        <xs:attribute type="xs:boolean" name="gridded" default="false" />
    </xs:complexType>

    <xs:complexType name="destination">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="DestinationConfig" />
            </xs:appinfo>
            <xs:documentation>
Details a type of output generated to contain or display evaluated statistics
            </xs:documentation>
        </xs:annotation>

        <xs:all>
            <!-- Specifies the type of output required. -->
            <xs:element name="outputType" type="outputTypeSelection" minOccurs="0" maxOccurs="1"/>           
            <!-- If output type is graphical (a chart)... -->
            <xs:element name="graphical" type="graphicalType" minOccurs="0" maxOccurs="1" />
            <xs:element name="netcdf" type="netcdfType" minOccurs="0" />
        </xs:all>

        <xs:attribute name="type" type="destinationType" default="numeric" />
        <xs:attribute name="decimalFormat" type="xs:string" />
    </xs:complexType>

    <xs:simpleType name="timeScaleFunction">
        <xs:annotation>
            <xs:documentation>
The function that was applied to values over time to determine what was recorded.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="total" />
            <xs:enumeration value="mean" />
            <xs:enumeration value="maximum" />
            <xs:enumeration value="minimum" />
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="duration">
        <xs:restriction base="xs:int"/>
    </xs:simpleType>
    <xs:simpleType name="durationUnit">
        <xs:annotation>
            <xs:documentation>
A unit of time
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <!-- Please note: these values are intentionally convertible to
            java.time.temporal.ChronoUnit values. Please only add values to this
            enum that can also be converted to java.time.temporal.ChronoUnit
            Also note: we define an "instant" as 1 minute or less. -->
            <xs:enumeration value="seconds" />
            <xs:enumeration value="minutes" />
            <xs:enumeration value="hours" />
            <xs:enumeration value="days" />
        </xs:restriction>
    </xs:simpleType>

    <!-- Base type for time scale information-->
    <xs:complexType name="timeScale">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="TimeScaleConfig" />
            </xs:appinfo>
            <xs:documentation>
Describes the time scale of a measurement within a time-series. The time scale includes a function that integrates the measurement
over a prescribed period, in prescribed time units.
            </xs:documentation>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="function" type="timeScaleFunction" default="mean" />
            <xs:element name="period" type="duration" />
            <xs:element name="unit" type="durationUnit" />
        </xs:sequence>
        <xs:attribute name="label" type="xs:string" />

    </xs:complexType>

    <!-- Declared time scale, which allows for a frequency -->
    <xs:complexType name="desiredTimeScale">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="DesiredTimeScaleConfig" />
            </xs:appinfo>
            <xs:documentation>
Additionally declares the frequency with which measurements may repeat at the desired time scale, in the same units
declared for the period. TODO: allow the frequency to be declared separately from the time scale and then model the
time scale within a single class, rather than two classes.
            </xs:documentation>
        </xs:annotation>

        <xs:complexContent>
            <xs:extension base="timeScale">
                <xs:sequence>
                    <xs:element name="frequency" type="duration" minOccurs="0" maxOccurs="1"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="dateCondition">
        <!-- xs:dateTime ends up being yucky XMLGregorianCalendar. Use string, let app deal with it. -->
        <xs:attribute name="earliest" type="xs:string" />
        <xs:attribute name="latest" type="xs:string" />
    </xs:complexType>

    <xs:complexType name="poolingWindow">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="PoolingWindowConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="period" type="duration" />
            <xs:element name="frequency" type="duration" minOccurs="0" />
            <xs:element name="unit" type="durationUnit" />
        </xs:sequence>
    </xs:complexType>


    <xs:complexType name="featureGroup">
        <xs:annotation>
            <xs:documentation>
                Used with featureService, a featureGroup has a "type" and a
                "value" that are passed through to the "select_by" and
                "selector" URL paths of the service, respectively. There is
                also a "pool" that indicates whether the features within the
                group should be pooled together into an N-feature group or 
                treated as singletons.
            </xs:documentation>
        </xs:annotation>

        <xs:all>
            <xs:element name="type" type="xs:string" />
            <xs:element name="value" type="xs:string" />
        </xs:all>
        <xs:attribute name="pool" type="xs:boolean" default="false" />
    </xs:complexType>

    <xs:complexType name="featureService">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:documentation>
                The place to declare a feature service url and additional groups
                of features to request from that service. One way to use the
                featureService is to let WRES use it to fill in missing feature
                names among explicitly declared features. Another way to use the
                featureService is to let WRES use it to get whole groups of
                features and append them to the declaration that goes through
                WRES.
            </xs:documentation>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="baseUrl" type="xs:anyURI" />
            <xs:element name="group" type="featureGroup" minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="pair">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="PairConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="unit" type="xs:string" minOccurs="0" maxOccurs="1" />
            <xs:element name="unitAlias" type="unitAlias" minOccurs="0" maxOccurs="unbounded" />
            <xs:element name="featureService" type="featureService" minOccurs="0" maxOccurs="1" />
            <xs:element name="feature" type="feature" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="featureGroup" type="featurePool" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="gridSelection" type="unnamedFeature" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="byTimeSeries" type="xs:boolean" default="false" minOccurs="0" />
            <xs:element name="leadHours" type="intBoundsType" minOccurs="0" />

            <!-- analysisDurations chooses which analysis durations to evaluate #65216, #61593 -->
            <xs:element name="analysisDurations" type="durationBoundsType" minOccurs="0" />
            <xs:element name="dates" type="dateCondition" minOccurs="0" />
            <xs:element name="issuedDates" type="dateCondition" minOccurs="0" />

            <!-- Intended for seasonal verification, GMT, valid time: -->
            <xs:element name="season" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:all>
                        <xs:element name="earliestMonth" type="xs:short" />
                        <xs:element name="earliestDay" type="xs:short" />
                        <xs:element name="latestMonth" type="xs:short" />
                        <xs:element name="latestDay" type="xs:short" />
                    </xs:all>
                </xs:complexType>
            </xs:element>
            <!-- values min and max should be in the unit above -->
            <xs:element name="values" type="doubleBoundsType" minOccurs="0" />

            <xs:element name="desiredTimeScale" type="desiredTimeScale" minOccurs="0" />

            <xs:element name="issuedDatesPoolingWindow" type="poolingWindow" minOccurs="0"/>
            <xs:element name="validDatesPoolingWindow" type="poolingWindow" minOccurs="0"/>
            <xs:element name="leadTimesPoolingWindow" type="poolingWindow" minOccurs="0"/>
            <xs:element name="crossPair" type="crossPair" minOccurs="0" />
        </xs:sequence>
        <xs:attribute name="label" type="xs:string" />
    </xs:complexType>

    <xs:complexType name ="crossPair">
           <xs:annotation>
                <xs:documentation>If present, use common pairs by reference time and 
                    valid time when evaluating right and baseline sources. If absent,  
                    retain all pairs of each type. Only applies when a baseline is 
                    declared. Employs fuzzy matching of reference times by default,
                    with exact matching as an option (exact="true"). With fuzzy matching, 
                    each time-series in the main set of pairs is matched with a 
                    time-series in the baseline set of pairs (and vice versa) according 
                    to the total duration between all reference times of a 
                    corresponding type. In other words, if there is an exact match, 
                    that will be used, else the time-series whose reference times 
                    are nearest overall. Once a time-series has been matched, it cannot
                    be re-used. Always uses exact matching for valid times.
                </xs:documentation>
           </xs:annotation>
        <xs:attribute name="exact" type="xs:boolean" default = "false" />
    </xs:complexType>

    <!-- A place to declare which metrics to generate, as distinct from what
         pairs should look like or where to save output files. -->
    <xs:complexType name="metrics">

        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="MetricsConfig" />
            </xs:appinfo>
            <xs:documentation>A collection of metrics to compute, together with their
                    associated thresholds. The minimumSampleSize defines the minimum 
                    number of samples for which a statistic will be computed. For 
                    measures on continuous variables, such as the mean error, the
                    minimum sample size corresponds to the number of pairs. For 
                    single-valued measures on dichotomous variables, such as the 
                    probability of detection, it corresponds to the smaller of the 
                    number of occurrences and non-occurrences on the left side of 
                    the pairs. For probabilistic measures on dichotomous variables, 
                    such as the Brier Score, it corresponds to the smaller of the 
                    number of occurrences and non-occurrences on the left side of 
                    the pairs, as represented by a probability of 1.0 and 0.0, 
                    respectively.
             </xs:documentation>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="thresholds" type="thresholds" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="minimumSampleSize" type="xs:int" minOccurs="0" maxOccurs="1" />
            <xs:element name="metric" type="metric" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="timeSeriesMetric" type="timeSeriesMetric" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>

    </xs:complexType>

    <xs:element name="project">
        <xs:annotation>
            <xs:documentation>This is the top level WRES project configuration
                XML element. Every project configuration must include this element
                and its four required sub-elements.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>

            <!-- for class naming using xjc-->
            <xs:annotation>
                <xs:appinfo>
                    <jaxb:class name="ProjectConfig" />
                </xs:appinfo>
            </xs:annotation>

            <xs:sequence>
                <xs:element name="inputs">
                    <xs:annotation>
                        <xs:documentation>Specifies the data to evaluate. The "left" data
                            specifies the "truth" against which the forecasts will be
                            evaluated, being typically observations (or simulations). The
                            "right" data specifies the forecasts to evaluate. The "baseline"
                            data specifies baseline forecasts against which the forecasts
                            will be compared when calculating skill scores, for example.
                            Instructions for how to indicate specific sources of data,
                            including flat files, USGS NWIS, the WRDS AHPS forecast API, are
                            provided with the elements below.
                        </xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:all>
                            <xs:element name="left" type="datasource" />
                            <xs:element name="right" type="datasource" />
                            <xs:element name="baseline" type="datasourceBaseline" minOccurs="0" maxOccurs="1" />
                        </xs:all>
                    </xs:complexType>
                </xs:element>

                <xs:element name="pair" type="pair">
                    <xs:annotation>
                        <xs:documentation>Specifies various aspects pertaining to how the
                            data will be prepared for evaluation, including setting the
                            measurement unit, features to include, lead times to include,
                            restricts on the valid times or issued times, season, desired
                            time scale, and pooling windows, among others.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>

                <xs:element name="metrics" type="metrics" minOccurs="1" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation>Specifies the metrics to calculate and the
                            parameters of those metrics, such as thresholds.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>

                <xs:element name="outputs">
                    <xs:annotation>
                        <xs:documentation>Specifies the types of outputs to generate,
                            including ASCII CSV files,
                        </xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="destination" type="destination" maxOccurs="unbounded"/>
                        </xs:sequence>

                        <xs:attribute name="durationFormat" type="durationUnit" default = "seconds" />

                    </xs:complexType>
                </xs:element>
            </xs:sequence>

            <xs:attribute name="label" type="xs:string" />
            <xs:attribute name="name" type="xs:string" default="unnamed project" />

        </xs:complexType>
    </xs:element>

</xs:schema>
