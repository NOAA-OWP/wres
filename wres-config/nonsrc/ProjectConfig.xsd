<?xml version="1.0" encoding="UTF-8" ?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:jaxb="http://java.sun.com/xml/ns/jaxb"
           jaxb:version="2.1"
           elementFormDefault="qualified">

    <xs:complexType name="doubleBoundsType">
        <xs:attribute name="minimum" type="xs:double" />
        <xs:attribute name="maximum" type="xs:double" />
    </xs:complexType>

    <xs:complexType name="intBoundsType">
        <xs:attribute name="minimum" type="xs:int" />
        <xs:attribute name="maximum" type="xs:int" />
    </xs:complexType>

    <xs:simpleType name="datasourceType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="ensemble forecasts" />
            <xs:enumeration value="single valued forecasts" />
            <xs:enumeration value="observations" />
            <xs:enumeration value="simulations" />
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="sourceTransformationType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="persistence" />
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="format">
        <xs:restriction base="xs:string">
            <xs:enumeration value="PI-XML" />
            <xs:enumeration value="netCDF" />
            <xs:enumeration value="datacard" />
            <xs:enumeration value="usgs" />
            <!-- Neither "archive" nor "all" make sense to me. The idea is to
                 help describe the actual format of the data when it is not
                 obvious from examining it. Filtering/conditioning is in another
                 section of the config. -Jesse -->
            <xs:enumeration value="archive" />
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="ensembleCondition">
        <xs:attribute name="label" type="xs:string" />
        <xs:attribute name="name" type="xs:string" />
        <xs:attribute name="member_id" type="xs:string" />
        <xs:attribute name="qualifier" type="xs:string" />
        <xs:attribute name="exclude" type="xs:boolean" default="false" />
    </xs:complexType>

    <xs:complexType name="feature">
        <xs:sequence>
            <xs:element name="alias" type="xs:string" minOccurs="0" maxOccurs="unbounded" />
            <xs:element name="coordinate" type="coordinateSelection" minOccurs="0" />
        </xs:sequence>
        <xs:attribute name="label" type="xs:string" />
        <xs:attribute name="locationId" type="xs:string" />
        <xs:attribute name="comid" type="xs:long" />
        <xs:attribute name="gage_id" type="xs:string" />
        <xs:attribute name="huc" type="xs:string" />
        <xs:attribute name="name" type="xs:string" />
        <xs:attribute name="rfc" type="xs:string" />
        <!-- WKT can specify a point or polygon. If not using WGS84 lon/lat,
             or if not using the same coordinate system in all sources,
             then it probably needs its own geographic coordinate system
             specified. -->
        <xs:attribute name="wkt" type="xs:string" />
    </xs:complexType>

    <xs:complexType name="coordinateSelection">
        <xs:sequence>
            <xs:element name="longitude" type="xs:float" />
            <xs:element name="latitude" type="xs:float" />
            <xs:element name="range" type="xs:float" />
        </xs:sequence>
    </xs:complexType>

    <!-- TODO revisit selection of a grid point by index - who wants? -->
    <xs:complexType name="variableIndex">
        <xs:attribute name="x" type="xs:int" />
        <xs:attribute name="y" type="xs:int" />
    </xs:complexType>

    <xs:complexType name="datasource">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="DataSourceConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="type" type="datasourceType" />

            <xs:element name="source" minOccurs="1" maxOccurs="unbounded">
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:anyURI">
                            <xs:attribute name="format" type="format" />
                            <!-- Can we remove unit below? Shouldn't the unit of
                                 the variable suffice? -Jesse -->
                            <xs:attribute name="unit" type="xs:string" default="" />
                            <xs:attribute name="locationId" type="xs:string" default="" />
                            <xs:attribute name="zoneOffset" type="xs:string" />
                            <!-- missingValue may have multiple comma delimited values like "-999, -996"-->
                            <xs:attribute name="missingValue" type="xs:string" default="-999.0" />
                            <xs:attribute name="pattern" type="xs:string" default="" />
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="variable">
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:string">
                            <xs:attribute name="label" type="xs:string" />
                            <xs:attribute name="unit" type="xs:string" />
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="transformation" type="sourceTransformationType" minOccurs="0" maxOccurs="1" />
            <xs:element name="ensemble" type="ensembleCondition" minOccurs="0" maxOccurs="unbounded" />
            <xs:element name="arbitraryFunctionToApplyToValues" type="xs:string" minOccurs="0" maxOccurs="1" />
            <xs:element name="timeShift" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="width" type="duration" />
                        <xs:element name="unit" type="durationUnit" />
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element name="existingTimeScale" type="timeScale" minOccurs="0" maxOccurs="1"/>
        </xs:sequence>
        <xs:attribute name="label" type="xs:string" />
    </xs:complexType>

    <!-- An enum to specify if the left, right, or baseline has been chosen. -->
    <xs:simpleType name="leftOrRightOrBaseline">
        <xs:restriction base="xs:string">
            <xs:enumeration value="left" />
            <xs:enumeration value="right" />
            <xs:enumeration value="baseline" />
        </xs:restriction>
    </xs:simpleType>

    <!-- An enum to specify if a threshold is a probability or real value. -->
    <xs:simpleType name="probabilityOrValue">
        <xs:restriction base="xs:string">
            <xs:enumeration value="probability" />
            <xs:enumeration value="value" />
        </xs:restriction>
    </xs:simpleType>

    <!-- Thresholds need to specify an operator suitable for thresholding -->
    <xs:simpleType name="thresholdOperator">
        <xs:restriction base="xs:string">
            <xs:enumeration value="equal to" />
            <xs:enumeration value="less than" />
            <xs:enumeration value="less than or equal to" />
            <xs:enumeration value="greater than" />
            <xs:enumeration value="greater than or equal to" />
        </xs:restriction>
    </xs:simpleType>

    <!-- Container for thresholds. -->
    <xs:complexType name="thresholds">

        <!-- for class naming using xjc -->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="ThresholdsConfig" />
            </xs:appinfo>
        </xs:annotation>

        <!-- A threshold contains a type, applyTo and operator and EITHER an external source OR an internal commaSeparatedValues. -->
        <xs:sequence>
	    <xs:element name="type" type="probabilityOrValue" default="probability" minOccurs="0" maxOccurs="1"/>
            <xs:element name="applyTo" type="leftOrRightOrBaseline" default="left" minOccurs="0" maxOccurs="1"/>
            <!-- Choice of using an internal source or an external source -->
            <xs:choice>
                <!-- Internal source -->
                <xs:element name="commaSeparatedValues" type="xs:string" default="0.05,0.1,0.25,0.50,0.75,0.90,0.95" minOccurs = "1"/>
                <!-- External source -->
                <xs:element name="source" minOccurs="1">
                    <xs:complexType>
                        <xs:simpleContent>
                            <xs:extension base="xs:anyURI">
                                <xs:attribute name="format" type="format" />
                                <xs:attribute name="unit" type="xs:string" default="" />
                                <xs:attribute name="missingValue" type="xs:string" default="-999.0" />
                            </xs:extension>
                        </xs:simpleContent>
                    </xs:complexType>
                </xs:element>
            </xs:choice>
            <xs:element name="operator" type="thresholdOperator" default="less than" minOccurs="0" maxOccurs="1" />
        </xs:sequence>
    </xs:complexType>

    <!-- There is a mapping between these names and the enum in MetricConstants.
         For now, these two lists must be periodically synchronized manually.-->
    <xs:simpleType name="metricConfigName">
        <xs:restriction base="xs:string">

            <!-- When user wishes to have all the metrics that are valid for a
                 given configuration -->
            <xs:enumeration value="all valid" />

            <xs:enumeration value="bias fraction" />
            <xs:enumeration value="box plot of errors by observed value" />
            <xs:enumeration value="box plot of errors by forecast value" />
            <xs:enumeration value="brier score" />
            <xs:enumeration value="brier skill score" />
            <xs:enumeration value="coefficient of determination" />
            <xs:enumeration value="contingency table" />
            <xs:enumeration value="pearson correlation coefficient" />
            <xs:enumeration value="continuous ranked probability score" />
            <xs:enumeration value="continuous ranked probability skill score" />
            <xs:enumeration value="threat score" />
            <xs:enumeration value="equitable threat score" />
            <xs:enumeration value="frequency bias" />
            <xs:enumeration value="index of agreement" />
            <xs:enumeration value="kling gupta efficiency" />
            <xs:enumeration value="mean absolute error" />
            <xs:enumeration value="mean error" />
            <xs:enumeration value="mean square error" />
            <xs:enumeration value="mean square error skill score" />
            <xs:enumeration value="peirce skill score" />
            <xs:enumeration value="probability of detection" />
            <xs:enumeration value="probability of false detection" />
            <xs:enumeration value="quantile quantile diagram" />
            <xs:enumeration value="rank histogram" />
            <xs:enumeration value="relative operating characteristic diagram" />
            <xs:enumeration value="relative operating characteristic score" />
            <xs:enumeration value="reliability diagram" />
            <xs:enumeration value="root mean square error" />
            <xs:enumeration value="sample size" />
	    <xs:enumeration value="time to peak error" />
            <xs:enumeration value="volumetric efficiency" />
        </xs:restriction>
    </xs:simpleType>

    <!-- An enumeration of summary statistics associated with a metric -->
    <xs:simpleType name="summaryStatisticsName">
        <xs:restriction base="xs:string">
            <!-- Allows for all summary statistics -->
            <xs:enumeration value="all valid" />

            <xs:enumeration value="mean" />
            <xs:enumeration value="median" />
            <xs:enumeration value="minimum" />
            <xs:enumeration value="maximum" />
            <xs:enumeration value="standard deviation" />
            <xs:enumeration value="mean absolute" />
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="summaryStatistics">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="SummaryStatisticsConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="name" type="summaryStatisticsName" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <!-- Base type for a metric -->
    <xs:complexType name="abstractMetric">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="AbstractMetricConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="name" type="metricConfigName" />
            <xs:element name="outputType" type="outputTypeSelection" minOccurs="0" />
            <xs:element name="templateResourceName" type="xs:anyURI" minOccurs="0" />
        </xs:sequence>

        <xs:attribute name="label" type="xs:string" />
    </xs:complexType>

    <!-- Metrics that accept thresholds -->
    <xs:complexType name="metric">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="MetricConfig" />
            </xs:appinfo>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="abstractMetric">
                <xs:sequence>
                    <xs:element name="thresholds" type="thresholds" minOccurs="0" maxOccurs="unbounded" />
                 </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!-- Metrics that consume time-series and may have summary statistics associated with them -->
    <xs:complexType name="timeSeriesMetric">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="TimeSeriesMetricConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:complexContent>
            <xs:extension base="abstractMetric">
                <xs:sequence>
                    <xs:element name="summaryStatistics" type="summaryStatistics" minOccurs="0" maxOccurs="1"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:simpleType name="destinationType">
        <xs:restriction base="xs:string">
	    <xs:enumeration value="csv" />
            <xs:enumeration value="png" />
            <xs:enumeration value="netcdf" />
            <xs:enumeration value="numeric" />
            <xs:enumeration value="graphic" />
            <xs:enumeration value="pairs" />
        </xs:restriction>
    </xs:simpleType>

    <!-- Possibilities for the outputType element. The "default" option indicates 
    that the default output configuration should be used when multiple options are 
    possible for the same type of output data. The default should also be assumed 
    when the output type is undefined.-->
    <xs:simpleType name="outputTypeSelection">
        <xs:restriction base="xs:string">
            <xs:enumeration value="default" />
            <xs:enumeration value="lead threshold" />
            <xs:enumeration value="threshold lead" />
	    <xs:enumeration value="pooling window" />
            <xs:enumeration value="single valued pairs" />
        </xs:restriction>
    </xs:simpleType>
    
    <!-- Element to store options related to generating graphics. -->
    <xs:complexType name="graphicalType">

        <xs:sequence>
            <!-- Specifies the override chart drawing parameters.  Will be processed as a String and passed to 
            charting tool so it can parse it.  Hence, the reason it is skipped. -->
            <xs:element name="config" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:any processContents="skip" namespace="##any" minOccurs="0" maxOccurs="unbounded" />
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:sequence>

        <!-- Image width. -->
        <xs:attribute name="width" type="xs:int" />
        
        <!-- Image height. -->
        <xs:attribute name="height" type="xs:int" />
        
        <!-- Location of the template file.  Every plot type has a default file.
        This allows for using a user customized file.  When searching for the 
        file it will begin by loading it as a system resource from the lib/conf
        directory and, if it is not found, then as a file on the file system. -->
        <xs:attribute name="template" type="xs:string" />
    </xs:complexType>

    <xs:complexType name="destination">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="DestinationConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="path" type="xs:anyURI" />
            <!-- Specifies the type of output required. -->
            <xs:element name="outputType" type="outputTypeSelection" minOccurs="0" maxOccurs="1"/>           
            <!-- If output type is graphical (a chart)... -->
            <xs:element name="graphical" type="graphicalType" minOccurs="0" maxOccurs="1" />
        </xs:sequence>

        <xs:attribute name="type" type="destinationType" default="numeric" />
        <xs:attribute name="decimalFormat" type="xs:string" />
    </xs:complexType>

    <xs:simpleType name="timeScaleFunction">
        <xs:restriction base="xs:string">
            <xs:enumeration value="none" />
            <xs:enumeration value="sum" />
            <xs:enumeration value="avg" />
            <xs:enumeration value="max" />
            <xs:enumeration value="min" />
            <xs:enumeration value="median" />
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="duration">
        <xs:restriction base="xs:int"/>
    </xs:simpleType>
    <xs:simpleType name="durationUnit">
        <xs:restriction base="xs:string">
            <!-- Please note: these values are intentionally convertible to
            java.time.temporal.ChronoUnit values. Please only add values to this
            enum that can also be converted to java.time.temporal.ChronoUnit
            Also note: we define an "instant" as 1 nanos. -->
            <xs:enumeration value="nanos" />
            <xs:enumeration value="seconds" />
            <xs:enumeration value="minutes" />
            <xs:enumeration value="hours" />
            <xs:enumeration value="days" />
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="timeWindowMode">
        <xs:restriction base="xs:string">
            <xs:enumeration value="back-to-back" />
            <xs:enumeration value="rolling" />
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="timeScale">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="TimeScaleConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="function" type="timeScaleFunction" default="avg" minOccurs="1" maxOccurs="1"/>
            <xs:element name="period" type="duration" minOccurs="1" maxOccurs="1"/>
            <xs:element name="frequency" type="duration" minOccurs="0" maxOccurs="1"/>
            <xs:element name="unit" type="durationUnit" />
        </xs:sequence>
        <xs:attribute name="label" type="xs:string" />
    </xs:complexType>

    <xs:complexType name="spaceAggregation">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="SpaceAggregationConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="function" type="spaceAggregationFunction" />
            <xs:element name="parameters" type="xs:string" />
        </xs:sequence>

        <xs:attribute name="label" type="xs:string" />
    </xs:complexType>

    <xs:complexType name="dateCondition">
        <!-- xs:dateTime ends up being yucky XMLGregorianCalendar. Use string, let app deal with it. -->
        <xs:attribute name="earliest" type="xs:string" />
        <xs:attribute name="latest" type="xs:string" />
    </xs:complexType>

    <xs:complexType name="poolingWindow">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="PoolingWindowConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="period" type="duration" minOccurs="0" />
            <xs:element name="frequency" type="duration" minOccurs="0"/>
            <xs:element name="unit" type="durationUnit" />
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="spaceAggregationFunction">
        <xs:restriction base="xs:string">
            <xs:enumeration value="scale" />
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="pair">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="PairConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="unit" type="xs:string" />
            <xs:element name="feature" type="feature" minOccurs="0" maxOccurs="unbounded"/>

            <xs:element name="leadHours" type="intBoundsType" minOccurs="0" />
            <xs:element name="dates" type="dateCondition" minOccurs="0" />
            <xs:element name="issuedDates" type="dateCondition" minOccurs="0" />

            <!-- Intended for seasonal verification, GMT, valid time: -->
            <xs:element name="season" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="earliestMonth" type="xs:short" />
                        <xs:element name="earliestDay" type="xs:short" />
                        <xs:element name="latestMonth" type="xs:short" />
                        <xs:element name="latestDay" type="xs:short" />
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <!-- values min and max should be in the unit above -->
            <xs:element name="values" type="doubleBoundsType" minOccurs="0" />

            <xs:element name="desiredTimeScale" type="timeScale" minOccurs="0" />

            <xs:element name="issuedDatesPoolingWindow" type="poolingWindow" minOccurs="0"/>
            <xs:element name="leadTimesPoolingWindow" type="poolingWindow" minOccurs="0"/>

            <!-- idea here is mask is a WKT, or optionally a filename,
                 so you could do either:
                 <mask file="file:///my/file.shp" />
                 OR
                 <mask>poly( whatever well-known-text )</mask> -->
            <xs:element name="mask" minOccurs="0">
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:string">
                            <xs:attribute name="file" type="xs:anyURI" />
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="label" type="xs:string" />
    </xs:complexType>

    <!-- A place to declare which metrics to generate, as distinct from what
         pairs should look like or where to save output files. -->
    <xs:complexType name="metrics">

        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="MetricsConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="thresholds" type="thresholds" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="metric" type="metric" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="timeSeriesMetric" type="timeSeriesMetric" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>

    </xs:complexType>

    <xs:element name="project">
        <xs:complexType>

            <!-- for class naming using xjc-->
            <xs:annotation>
                <xs:appinfo>
                    <jaxb:class name="ProjectConfig" />
                </xs:appinfo>
            </xs:annotation>

            <xs:sequence>

                <xs:element name="inputs">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="left" type="datasource" />
                            <xs:element name="right" type="datasource" />
                            <xs:element name="baseline" type="datasource" minOccurs="0" maxOccurs="1" />
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>

                <xs:element name="pair" type="pair"/>

                <xs:element name="metrics" type="metrics" />

                <xs:element name="outputs">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="destination" type="destination" maxOccurs="unbounded"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>

            <xs:attribute name="label" type="xs:string" />
            <xs:attribute name="name" type="xs:string" default="unnamed project" />

        </xs:complexType>
    </xs:element>

</xs:schema>

