<?xml version="1.0" encoding="UTF-8" ?>
<?xml-stylesheet type="text/xsl" href="xs3p.xsl"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:jaxb="http://java.sun.com/xml/ns/jaxb"
           jaxb:version="2.1"
           elementFormDefault="qualified">

    <xs:complexType name="doubleBoundsType">
        <xs:attribute name="minimum" type="xs:double" />
        <xs:attribute name="maximum" type="xs:double" />
        <xs:attribute name="default_minimum" type="xs:double" />
        <xs:attribute name="default_maximum" type="xs:double" />
    </xs:complexType>

    <xs:complexType name="intBoundsType">
        <xs:attribute name="minimum" type="xs:int" />
        <xs:attribute name="maximum" type="xs:int" />
    </xs:complexType>

    <xs:simpleType name="datasourceType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="ensemble forecasts" />
            <xs:enumeration value="single valued forecasts" />
            <xs:enumeration value="observations" />
            <xs:enumeration value="simulations" />
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="sourceTransformationType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="persistence" />
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="format">
        <xs:restriction base="xs:string">
            <xs:enumeration value="PI-XML" />
            <xs:enumeration value="netCDF" />
            <xs:enumeration value="datacard" />
            <xs:enumeration value="usgs" />
            <xs:enumeration value="s3" />
            <!-- Neither "archive" nor "all" make sense to me. The idea is to
                 help describe the actual format of the data when it is not
                 obvious from examining it. Filtering/conditioning is in another
                 section of the config. -Jesse -->
            <xs:enumeration value="archive" />
            <xs:enumeration value="wrds" />
            <xs:enumeration value="csv" />
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="ensembleCondition">
        <xs:attribute name="label" type="xs:string" />
        <xs:attribute name="name" type="xs:string" />
        <xs:attribute name="member_id" type="xs:string" />
        <xs:attribute name="qualifier" type="xs:string" />
        <xs:attribute name="exclude" type="xs:boolean" default="false" />
    </xs:complexType>

    <xs:complexType name="feature">
        <xs:sequence>
            <xs:element name="alias" type="xs:string" minOccurs="0" maxOccurs="unbounded" />
            <xs:element name="coordinate" type="coordinateSelection" minOccurs="0" />
            <xs:element name="polygon" type="PolygonSelection" minOccurs="0"/>
            <xs:element name="circle" type="CircleSelection" minOccurs="0" />
        </xs:sequence>
        <xs:attribute name="label" type="xs:string" />
        <xs:attribute name="locationId" type="xs:string" />
        <xs:attribute name="comid" type="xs:long" />
        <xs:attribute name="gage_id" type="xs:string" />
        <xs:attribute name="huc" type="xs:string" />
        <xs:attribute name="name" type="xs:string" />
        <xs:attribute name="rfc" type="xs:string" />
        <xs:attribute name="state" type="xs:string" />
        <!-- WKT can specify a point or polygon. If not using WGS84 lon/lat,
             or if not using the same coordinate system in all sources,
             then it probably needs its own geographic coordinate system
             specified. -->
        <xs:attribute name="wkt" type="xs:string" />
    </xs:complexType>

    <xs:complexType name="coordinateSelection">
        <xs:sequence>
            <xs:element name="longitude" type="xs:float" />
            <xs:element name="latitude" type="xs:float" />
            <xs:element name="range" type="xs:float" />
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="CircleSelection">
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="Circle" />
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="latitude" type="xs:float" />
            <xs:element name="longitude" type="xs:float" />
            <xs:element name="diameter" type="xs:float" />
        </xs:sequence>
        <xs:attribute name="srid" type="xs:integer" default="4326" />
    </xs:complexType>

    <xs:complexType name="PolygonSelection">
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="Polygon" />
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="point" minOccurs="3" maxOccurs="unbounded" >
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="latitude" type="xs:float" />
                        <xs:element name="longitude" type="xs:float" />
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="srid" type="xs:integer" default="4326" />
    </xs:complexType>

    <xs:complexType name="datasource">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="DataSourceConfig" />
            </xs:appinfo>
            <xs:documentation>
                Used to explain what data to use for evaluation
            </xs:documentation>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="type" type="datasourceType" />

            <xs:element name="source" minOccurs="1" maxOccurs="unbounded">
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:anyURI">
                            <xs:attribute name="format" type="format" />
                            <!-- Can we remove unit below? Shouldn't the unit of
                                 the variable suffice? -Jesse -->
                            <xs:attribute name="unit" type="xs:string" default="" />
                            <xs:attribute name="locationId" type="xs:string" default="" />
                            <xs:attribute name="zoneOffset" type="xs:string" />
                            <!-- missingValue may have multiple comma delimited values like "-999, -996"-->
                            <xs:attribute name="missingValue" type="xs:string" default="-999.0" />
                            <xs:attribute name="pattern" type="xs:string" default="" />
                            <xs:attribute name="has_header" type="xs:boolean" default="false" />
                            <xs:attribute name="bucket" type="xs:string" />
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="variable">
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:string">
                            <xs:attribute name="label" type="xs:string" />
                            <xs:attribute name="unit" type="xs:string" />
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="transformation" type="sourceTransformationType" minOccurs="0" maxOccurs="1" />
            <xs:element name="ensemble" type="ensembleCondition" minOccurs="0" maxOccurs="unbounded" />
            <xs:element name="arbitraryFunctionToApplyToValues" type="xs:string" minOccurs="0" maxOccurs="1" />
            <xs:element name="timeShift" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="width" type="duration" />
                        <xs:element name="unit" type="durationUnit" />
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element name="existingTimeScale" type="timeScale" minOccurs="0" maxOccurs="1"/>
        </xs:sequence>
        <xs:attribute name="label" type="xs:string" />
    </xs:complexType>

    <xs:simpleType name="thresholdFormat">
        <xs:restriction base="xs:string">
            <xs:enumeration value="csv" />
        </xs:restriction>
    </xs:simpleType>

    <!-- An enum to specify the scope of the thresholds when filtering paired data. -->
    <xs:simpleType name="thresholdDataType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="left" />
            <xs:enumeration value="right" />
            <xs:enumeration value="left and right" />
            <xs:enumeration value="any right" />
            <xs:enumeration value="left and any right" />
            <xs:enumeration value="right mean" />
            <xs:enumeration value="left and right mean" />
        </xs:restriction>
    </xs:simpleType>

    <!-- An enum to specify if a threshold is a probability or real value. -->
    <xs:simpleType name="thresholdType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="probability" />
            <xs:enumeration value="value" />
	    <xs:enumeration value="probability classifier" />
        </xs:restriction>
    </xs:simpleType>

    <!-- Thresholds need to specify an operator suitable for thresholding -->
    <xs:simpleType name="thresholdOperator">
        <xs:restriction base="xs:string">
            <xs:enumeration value="equal to" />
            <xs:enumeration value="less than" />
            <xs:enumeration value="less than or equal to" />
            <xs:enumeration value="greater than" />
            <xs:enumeration value="greater than or equal to" />
        </xs:restriction>
    </xs:simpleType>

    <!-- Container for thresholds. -->
    <xs:complexType name="thresholds">

        <!-- for class naming using xjc -->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="ThresholdsConfig" />
            </xs:appinfo>
        </xs:annotation>

        <!-- A threshold contains a type, applyTo and operator and EITHER an external source OR an internal commaSeparatedValues. -->
        <xs:sequence>
	    <xs:element name="type" type="thresholdType" default="probability" minOccurs="0" maxOccurs="1"/>
            <xs:element name="applyTo" type="thresholdDataType" minOccurs="0" maxOccurs="1"/>
            <!-- Choice of using an internal source or an external source -->
            <xs:choice>
                <!-- Internal source -->
                <xs:element name="commaSeparatedValues" type="xs:string" default="0.05,0.1,0.25,0.50,0.75,0.90,0.95" minOccurs = "1"/>
                <!-- External source -->
                <xs:element name="source" minOccurs="1">
                    <xs:complexType>
                        <xs:simpleContent>
                            <xs:extension base="xs:anyURI">
                                <xs:attribute name="format" type="thresholdFormat" use="required" />
                                <xs:attribute name="unit" type="xs:string" default="" />
                                <xs:attribute name="missingValue" type="xs:string" default="-999.0" />
                            </xs:extension>
                        </xs:simpleContent>
                    </xs:complexType>
                </xs:element>
            </xs:choice>
            <xs:element name="operator" type="thresholdOperator" default="greater than" minOccurs="0" maxOccurs="1" />
        </xs:sequence>
    </xs:complexType>

    <!-- There is a mapping between these names and the enum in MetricConstants.
         For now, these two lists must be periodically synchronized manually.-->
    <xs:simpleType name="metricConfigName">
        <xs:restriction base="xs:string">

            <!-- When user wishes to have all the metrics that are valid for a
                 given configuration -->
            <xs:enumeration value="all valid" />

            <xs:enumeration value="bias fraction" />
            <xs:enumeration value="box plot of errors by observed value" />
            <xs:enumeration value="box plot of errors by forecast value" />
            <xs:enumeration value="brier score" />
            <xs:enumeration value="brier skill score" />
            <xs:enumeration value="coefficient of determination" />
            <xs:enumeration value="contingency table" />
            <xs:enumeration value="pearson correlation coefficient" />
            <xs:enumeration value="continuous ranked probability score" />
            <xs:enumeration value="continuous ranked probability skill score" />
            <xs:enumeration value="threat score" />
            <xs:enumeration value="equitable threat score" />
            <xs:enumeration value="frequency bias" />
            <xs:enumeration value="index of agreement" />
            <xs:enumeration value="kling gupta efficiency" />
            <xs:enumeration value="mean absolute error" />
            <xs:enumeration value="mean error" />
            <xs:enumeration value="mean square error" />
            <xs:enumeration value="mean square error skill score" />
            <xs:enumeration value="peirce skill score" />
            <xs:enumeration value="probability of detection" />
            <xs:enumeration value="probability of false detection" />
            <xs:enumeration value="quantile quantile diagram" />
            <xs:enumeration value="rank histogram" />
            <xs:enumeration value="relative operating characteristic diagram" />
            <xs:enumeration value="relative operating characteristic score" />
            <xs:enumeration value="reliability diagram" />
            <xs:enumeration value="root mean square error" />
            <xs:enumeration value="sample size" />
            <xs:enumeration value="sum of square error" />
            <xs:enumeration value="volumetric efficiency" />
        </xs:restriction>
    </xs:simpleType>

    <!-- There is a mapping between these names and the enum in MetricConstants.
         For now, these two lists must be periodically synchronized manually.-->
    <xs:simpleType name="timeSeriesMetricConfigName">
        <xs:restriction base="xs:string">

            <!-- When user wishes to have all the metrics that are valid for a
                 given configuration -->
            <xs:enumeration value="all valid" />

	    <xs:enumeration value="time to peak error" />
            <xs:enumeration value="time to peak relative error" />
        </xs:restriction>
    </xs:simpleType>

    <!-- An enumeration of summary statistics associated with a metric -->
    <xs:simpleType name="summaryStatisticsName">
        <xs:restriction base="xs:string">
            <!-- Allows for all summary statistics -->
            <xs:enumeration value="all valid" />

            <xs:enumeration value="mean" />
            <xs:enumeration value="median" />
            <xs:enumeration value="minimum" />
            <xs:enumeration value="maximum" />
            <xs:enumeration value="standard deviation" />
            <xs:enumeration value="mean absolute" />
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="summaryStatistics">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="SummaryStatisticsConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="name" type="summaryStatisticsName" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <!-- Base type for a metric -->
    <xs:complexType name="abstractMetric" abstract="true">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="AbstractMetricConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="templateResourceName" type="xs:string" minOccurs="0" />
        </xs:sequence>

        <xs:attribute name="label" type="xs:string" />
    </xs:complexType>

    <!-- Ordinary metrics -->
    <xs:complexType name="metric">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="MetricConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:complexContent>
            <xs:extension base="abstractMetric">
                <xs:sequence>
                    <xs:element name="name" type="metricConfigName" />
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!-- Metrics that consume time-series and may have summary statistics associated with them -->
    <xs:complexType name="timeSeriesMetric">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="TimeSeriesMetricConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:complexContent>
            <xs:extension base="abstractMetric">
                <xs:sequence>
                    <xs:element name="name" type="timeSeriesMetricConfigName" />
                    <xs:element name="summaryStatistics" type="summaryStatistics" minOccurs="0" maxOccurs="1"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:simpleType name="destinationType">
        <xs:restriction base="xs:string">
	    <xs:enumeration value="csv" />
            <xs:enumeration value="png" />
            <xs:enumeration value="netcdf" />
            <xs:enumeration value="numeric" />
            <xs:enumeration value="graphic" />
            <xs:enumeration value="pairs" />
        </xs:restriction>
    </xs:simpleType>

    <!-- Possibilities for the outputType element. The "default" option indicates 
    that the default output configuration should be used when multiple options are 
    possible for the same type of output data. The default should also be assumed 
    when the output type is undefined.-->
    <xs:simpleType name="outputTypeSelection">
        <xs:restriction base="xs:string">
            <xs:enumeration value="default" />
            <xs:enumeration value="lead threshold" />
            <xs:enumeration value="threshold lead" />
            <xs:enumeration value="single valued pairs" />
        </xs:restriction>
    </xs:simpleType>
    
    <!-- Element to store options related to generating graphics. -->
    <xs:complexType name="graphicalType">

        <xs:sequence>
            <!-- Specifies the override chart drawing parameters.  Will be processed as a String and passed to 
            charting tool so it can parse it.  Hence, the reason it is skipped. -->
            <xs:element name="config" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:any processContents="skip" namespace="##any" minOccurs="0" maxOccurs="unbounded" />
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:sequence>

        <!-- Image width. -->
        <xs:attribute name="width" type="xs:int" />
        
        <!-- Image height. -->
        <xs:attribute name="height" type="xs:int" />
        
        <!-- Location of the template file.  Every plot type has a default file.
        This allows for using a user customized file.  When searching for the 
        file it will begin by loading it as a system resource from the lib/conf
        directory and, if it is not found, then as a file on the file system. -->
        <xs:attribute name="template" type="xs:string" />
    </xs:complexType>

    <!-- Element to store options related to generating Netcdf output -->
    <xs:complexType name="netcdfType">
        <xs:sequence>
            <!-- Specifies the path to a template. Eventually, we'll want to
            create one from the input files if one isn't supplied -->
            <xs:element type="xs:string" name="templatePath" minOccurs="0"  />
        </xs:sequence>
        <!-- Dictates the name of the variable to use for vector coordinates -->
        <xs:attribute type="xs:string" name="vectorVariable" default="feature_id" />

        <!-- Dictates the name of the variable that contains the y coordinates for gridded data -->
        <xs:attribute type="xs:string" name="gridYVariable" default="y" />

        <!-- Dictates the name of the variable that contains the x coordinates for the gridded data -->
        <xs:attribute type="xs:string" name="gridXVariable" default="x" />

        <xs:attribute type="xs:boolean" name="gridded" default="false" />
    </xs:complexType>

    <xs:complexType name="destination">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="DestinationConfig" />
            </xs:appinfo>
            <xs:documentation>
Details a type of output generated to contain or display evaluated statistics
            </xs:documentation>
        </xs:annotation>

        <xs:sequence>
            <!-- Specifies the type of output required. -->
            <xs:element name="outputType" type="outputTypeSelection" minOccurs="0" maxOccurs="1"/>           
            <!-- If output type is graphical (a chart)... -->
            <xs:element name="graphical" type="graphicalType" minOccurs="0" maxOccurs="1" />
            <xs:element name="netcdf" type="netcdfType" minOccurs="0" />
        </xs:sequence>

        <xs:attribute name="type" type="destinationType" default="numeric" />
        <xs:attribute name="decimalFormat" type="xs:string" />
    </xs:complexType>

    <xs:simpleType name="timeScaleFunction">
        <xs:annotation>
            <xs:documentation>
The function that was applied to values over time to determine what was recorded.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="none" />
            <xs:enumeration value="total" />
            <xs:enumeration value="mean" />
            <xs:enumeration value="maximum" />
            <xs:enumeration value="minimum" />
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="duration">
        <xs:restriction base="xs:int"/>
    </xs:simpleType>
    <xs:simpleType name="durationUnit">
        <xs:annotation>
            <xs:documentation>
A unit of time
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <!-- Please note: these values are intentionally convertible to
            java.time.temporal.ChronoUnit values. Please only add values to this
            enum that can also be converted to java.time.temporal.ChronoUnit
            Also note: we define an "instant" as 1 nanos. -->
            <xs:enumeration value="nanos" />
            <xs:enumeration value="seconds" />
            <xs:enumeration value="minutes" />
            <xs:enumeration value="hours" />
            <xs:enumeration value="days" />
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="timeScale">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="TimeScaleConfig" />
            </xs:appinfo>
            <xs:documentation>
Details the period and frequency and by what function values are temporally scaled. If no frequency is specified
the frequency becomes equivalent to the period.
            </xs:documentation>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="function" type="timeScaleFunction" default="mean" minOccurs="1" maxOccurs="1"/>
            <xs:element name="period" type="duration" minOccurs="1" maxOccurs="1"/>
            <xs:element name="frequency" type="duration" minOccurs="0" maxOccurs="1"/>
            <xs:element name="unit" type="durationUnit" />
        </xs:sequence>
        <xs:attribute name="label" type="xs:string" />
    </xs:complexType>

    <xs:complexType name="dateCondition">
        <!-- xs:dateTime ends up being yucky XMLGregorianCalendar. Use string, let app deal with it. -->
        <xs:attribute name="earliest" type="xs:string" />
        <xs:attribute name="latest" type="xs:string" />
    </xs:complexType>

    <xs:complexType name="poolingWindow">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="PoolingWindowConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="period" type="duration" minOccurs="0" />
            <xs:element name="frequency" type="duration" minOccurs="0"/>
            <xs:element name="unit" type="durationUnit" />
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="pair">

        <!-- for class naming using xjc-->
        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="PairConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="unit" type="xs:string" />
            <xs:element name="feature" type="feature" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="byTimeSeries" type="xs:boolean" default="false" minOccurs="0" />
            <xs:element name="leadHours" type="intBoundsType" minOccurs="0" />
            <xs:element name="dates" type="dateCondition" minOccurs="0" />
            <xs:element name="issuedDates" type="dateCondition" minOccurs="0" />

            <!-- Intended for seasonal verification, GMT, valid time: -->
            <xs:element name="season" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="earliestMonth" type="xs:short" />
                        <xs:element name="earliestDay" type="xs:short" />
                        <xs:element name="latestMonth" type="xs:short" />
                        <xs:element name="latestDay" type="xs:short" />
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <!-- values min and max should be in the unit above -->
            <xs:element name="values" type="doubleBoundsType" minOccurs="0" />

            <xs:element name="desiredTimeScale" type="timeScale" minOccurs="0" />

            <xs:element name="issuedDatesPoolingWindow" type="poolingWindow" minOccurs="0"/>
            <xs:element name="leadTimesPoolingWindow" type="poolingWindow" minOccurs="0"/>

            <!-- idea here is mask is a WKT, or optionally a filename,
                 so you could do either:
                 <mask file="file:///my/file.shp" />
                 OR
                 <mask>poly( whatever well-known-text )</mask> -->
            <xs:element name="mask" minOccurs="0">
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:string">
                            <xs:attribute name="file" type="xs:anyURI" />
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="label" type="xs:string" />
    </xs:complexType>

    <!-- A place to declare which metrics to generate, as distinct from what
         pairs should look like or where to save output files. -->
    <xs:complexType name="metrics">

        <xs:annotation>
            <xs:appinfo>
                <jaxb:class name="MetricsConfig" />
            </xs:appinfo>
        </xs:annotation>

        <xs:sequence>
            <xs:element name="thresholds" type="thresholds" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="metric" type="metric" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="timeSeriesMetric" type="timeSeriesMetric" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>

    </xs:complexType>

    <xs:element name="project">
        <xs:complexType>

            <!-- for class naming using xjc-->
            <xs:annotation>
                <xs:appinfo>
                    <jaxb:class name="ProjectConfig" />
                </xs:appinfo>
            </xs:annotation>

            <xs:sequence>

                <xs:element name="inputs">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="left" type="datasource" />
                            <xs:element name="right" type="datasource" />
                            <xs:element name="baseline" type="datasource" minOccurs="0" maxOccurs="1" />
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>

                <xs:element name="pair" type="pair"/>

                <xs:element name="metrics" type="metrics" minOccurs ="1" maxOccurs="unbounded"/>

                <xs:element name="outputs">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="destination" type="destination" maxOccurs="unbounded"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>

            <xs:attribute name="label" type="xs:string" />
            <xs:attribute name="name" type="xs:string" default="unnamed project" />

        </xs:complexType>
    </xs:element>

</xs:schema>

