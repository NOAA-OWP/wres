package wres.control;

import java.io.IOException;
import java.time.Duration;
import java.time.Instant;
import java.util.EnumMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.function.BiPredicate;
import java.util.function.Consumer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import wres.config.ProjectConfigException;
import wres.config.generated.DestinationConfig;
import wres.config.generated.DestinationType;
import wres.config.generated.ProjectConfig;
import wres.config.generated.ProjectConfig.Outputs;
import wres.datamodel.MetricConstants.MetricOutputGroup;
import wres.datamodel.metadata.MetricOutputMetadata;
import wres.datamodel.outputs.BoxPlotOutput;
import wres.datamodel.outputs.DoubleScoreOutput;
import wres.datamodel.outputs.DurationScoreOutput;
import wres.datamodel.outputs.MatrixOutput;
import wres.datamodel.outputs.MetricOutputAccessException;
import wres.datamodel.outputs.MetricOutputForProjectByTimeAndThreshold;
import wres.datamodel.outputs.MetricOutputMultiMapByTimeAndThreshold;
import wres.datamodel.outputs.MultiVectorOutput;
import wres.datamodel.outputs.PairedOutput;
import wres.io.config.ConfigHelper;
import wres.io.config.ProjectConfigPlus;
import wres.io.writing.SharedWriters;
import wres.io.writing.commaseparated.CommaSeparatedBoxPlotWriter;
import wres.io.writing.commaseparated.CommaSeparatedDiagramWriter;
import wres.io.writing.commaseparated.CommaSeparatedMatrixWriter;
import wres.io.writing.commaseparated.CommaSeparatedPairedWriter;
import wres.io.writing.commaseparated.CommaSeparatedScoreWriter;
import wres.io.writing.png.PNGBoxPlotWriter;
import wres.io.writing.png.PNGDiagramWriter;
import wres.io.writing.png.PNGDoubleScoreWriter;
import wres.io.writing.png.PNGDurationScoreWriter;
import wres.io.writing.png.PNGPairedWriter;

/**
 * <p>A processor that generates metric products. Products are generated by registering instances of {@link Consumer} 
 * for particular types and formats of output data. The consumers are stored by {@link MetricOutputGroup}, i.e. by 
 * type of output data. Each store contains the consumers for any formats of output required, i.e. any
 * {@link DestinationType}.</p>
 * 
 * <p>Outputs may be written unconditionally, for all types and formats available, or conditionally, for specific 
 * combinations of type and format. Conditional writing is determined on construction with a {@link BiPredicate} 
 * condition on {@link MetricOutputGroup} and {@link DestinationType}.</p>.
 * 
 * @author james.brown@hydrosolved.com
 * @author jesse.bickel@***REMOVED***
 */

class ProductProcessor implements Consumer<MetricOutputForProjectByTimeAndThreshold>
{

    /**
     * Logger.
     */

    private static final Logger LOGGER = LoggerFactory.getLogger( ProductProcessor.class );

    /**
     * Null output error string
     */

    private static final String NULL_OUTPUT_STRING = "Specify non-null outputs for product generation.";

    /**
     * The project configuration.
     */

    private final ProjectConfig projectConfig;

    /**
     * The augmented project configuration.
     */

    private final ProjectConfigPlus projectConfigPlus;

    /**
     * Only writes when the condition is true.
     */

    private final BiPredicate<MetricOutputGroup, DestinationType> writeWhenTrue;

    /**
     * Store of consumers for processing {@link DoubleScoreOutput} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<MetricOutputMultiMapByTimeAndThreshold<DoubleScoreOutput>>> doubleScoreConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link DurationScoreOutput} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<MetricOutputMultiMapByTimeAndThreshold<DurationScoreOutput>>> durationScoreConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link MultiVectorOutput} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<MetricOutputMultiMapByTimeAndThreshold<MultiVectorOutput>>> diagramConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link BoxPlotOutput} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<MetricOutputMultiMapByTimeAndThreshold<BoxPlotOutput>>> boxPlotConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link MatrixOutput} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<MetricOutputMultiMapByTimeAndThreshold<MatrixOutput>>> matrixConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link PairedOutput} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<MetricOutputMultiMapByTimeAndThreshold<PairedOutput<Instant, Duration>>>> pairedConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * Build a product processor that writes unconditionally
     * 
     * @param projectConfigPlus the project configuration
     * @throws NullPointerException if any of the inputs are null
     * @throws WresProcessingException if the project is invalid for writing
     */

    ProductProcessor( final ProjectConfigPlus projectConfigPlus )
    {
        // Write unconditionally
        this( projectConfigPlus, ( x, y ) -> true );
    }

    /**
     * Build a product processor that writes conditionally.
     * 
     * @param projectConfigPlus the project configuration
     * @param writeWhenTrue the condition under which outputs should be written
     * @throws NullPointerException if any of the inputs are null
     * @throws WresProcessingException if the project is invalid for writing
     */

    ProductProcessor( final ProjectConfigPlus projectConfigPlus,
                      final BiPredicate<MetricOutputGroup, DestinationType> writeWhenTrue )
    {
        this( projectConfigPlus, writeWhenTrue, null);
    }    

    /**
     * Build a product processor that writes conditionally.
     * 
     * @param projectConfigPlus the project configuration
     * @param writeWhenTrue the condition under which outputs should be written
     * @param sharedWriters an optional set of shared writers to consume outputs
     * @throws NullPointerException if any of the inputs are null
     * @throws WresProcessingException if the project is invalid for writing
     */

    ProductProcessor( final ProjectConfigPlus projectConfigPlus,
                      final BiPredicate<MetricOutputGroup, DestinationType> writeWhenTrue,
                      final SharedWriters sharedWriters )
    {
        Objects.requireNonNull( projectConfigPlus,
                                "Specify a non-null configuration for the results processor." );

        Objects.requireNonNull( writeWhenTrue, "Specify a non-null condition to ignore." );

        this.projectConfigPlus = projectConfigPlus;

        this.projectConfig = this.projectConfigPlus.getProjectConfig();

        this.writeWhenTrue = writeWhenTrue;

        // Register output consumers
        try
        {
            buildConsumers( sharedWriters );
        }
        catch ( ProjectConfigException | IOException e )
        {
            throw new WresProcessingException( "While processing the project configuration to write output:", e );
        }
    }

    /**
     * Produces graphical and numerical output for each type available in the input.
     * 
     * @param input the input containing results for one project
     * @throws WresProcessingException if the outputs could not be written
     */

    @Override
    public void accept( final MetricOutputForProjectByTimeAndThreshold input )
    {

        try
        {
            // Multivector output available
            if ( input.hasOutput( MetricOutputGroup.MULTIVECTOR ) )
            {
                processDiagramOutputs( input.getMultiVectorOutput() );
            }

            // Box-plot output available
            if ( input.hasOutput( MetricOutputGroup.BOXPLOT ) )
            {
                processBoxPlotOutputs( input.getBoxPlotOutput() );
            }

            // Matrix output available
            if ( input.hasOutput( MetricOutputGroup.MATRIX ) )
            {
                processMatrixOutputs( input.getMatrixOutput() );
            }

            // Ordinary scores available
            if ( input.hasOutput( MetricOutputGroup.DOUBLE_SCORE ) )
            {
                processDoubleScoreOutputs( input.getDoubleScoreOutput() );
            }

            // Duration scores available
            if ( input.hasOutput( MetricOutputGroup.DURATION_SCORE ) )
            {
                processDurationScoreOutputs( input.getDurationScoreOutput() );
            }

            // Paired metric output available
            if ( input.hasOutput( MetricOutputGroup.PAIRED ) )
            {
                processPairedOutputByInstantDuration( input.getPairedOutput() );
            }
        }
        catch ( final MetricOutputAccessException | IOException e )
        {
            if ( Thread.currentThread().isInterrupted() )
            {
                LOGGER.warn( "Interrupted while processing intermediate results:", e );
            }
            throw new WresProcessingException( "Error while processing intermediate results:", e );
        }
    }

    /**
     * <p>Builds a set of consumers for writing based on the project configuration.</p>
     * 
     * <p>Edit this method as new consumer types are supported by the project configuration.</p>
     * 
     * @param sharedWriters an optional set of shared writers
     * @throws ProjectConfigException if the project configuration is invalid for writing
     */

    private void buildConsumers( SharedWriters sharedWriters ) throws ProjectConfigException, IOException
    {
        // There is one consumer per project for each type, because consumers are built
        // with projects, not destinations. The consumers must iterate destinations.

        // Register consumers for the NetCDF output type
        if ( configNeedsThisTypeOfOutput( DestinationType.NETCDF ) )
        {
            buildNetCDFConsumers( sharedWriters );
        }

        // Register consumers for the CSV output type
        if ( configNeedsThisTypeOfOutput( DestinationType.CSV ) )
        {
            buildCommaSeparatedConsumers();
        }

        // Register consumers for the PNG output type
        if ( configNeedsThisTypeOfOutput( DestinationType.PNG ) )
        {
            buildPortableNetworkGraphicsConsumers();
        }

    }

    /**
     * Builds a set of consumers for writing files of Comma Separated Values (CSV).
     * 
     * @throws ProjectConfigException if the project configuration is invalid for writing
     */

    private void buildCommaSeparatedConsumers() throws ProjectConfigException
    {
        // Build the consumers conditionally
        if ( writeWhenTrue.test( MetricOutputGroup.MULTIVECTOR, DestinationType.CSV ) )
        {
            diagramConsumers.put( DestinationType.CSV,
                                  CommaSeparatedDiagramWriter.of( projectConfig ) );
        }

        if ( writeWhenTrue.test( MetricOutputGroup.BOXPLOT, DestinationType.CSV ) )
        {
            boxPlotConsumers.put( DestinationType.CSV,
                                  CommaSeparatedBoxPlotWriter.of( projectConfig ) );
        }

        if ( writeWhenTrue.test( MetricOutputGroup.MATRIX, DestinationType.CSV ) )
        {
            matrixConsumers.put( DestinationType.CSV,
                                 CommaSeparatedMatrixWriter.of( projectConfig ) );
        }

        if ( writeWhenTrue.test( MetricOutputGroup.PAIRED, DestinationType.CSV ) )
        {
            pairedConsumers.put( DestinationType.CSV,
                                 CommaSeparatedPairedWriter.of( projectConfig ) );
        }

        if ( writeWhenTrue.test( MetricOutputGroup.DOUBLE_SCORE, DestinationType.CSV ) )
        {
            doubleScoreConsumers.put( DestinationType.CSV,
                                      CommaSeparatedScoreWriter.of( projectConfig ) );
        }

        if ( writeWhenTrue.test( MetricOutputGroup.DURATION_SCORE, DestinationType.CSV ) )
        {
            durationScoreConsumers.put( DestinationType.CSV,
                                        CommaSeparatedScoreWriter.of( projectConfig ) );
        }
    }

    /**
     * Builds a set of consumers for writing files in Portable Network Graphics (PNG) format.
     * 
     * TODO: remove the dependence of this class on ProjectConfigPlus via the graphics strings required by 
     * the consumers built in this method. Instead, pass on ProjectConfig together with graphics strings or an 
     * alternative representation of project configuration. The ProjectConfigPlus is not intended for sharing.
     * JFB: On reconsideration, the ProjectConfigPlus was precisely intended
     * for sharing with the graphics generator. So whatever is needed to pass
     * the ProjectConfigPlus to the graphics generator is needed and should stay.
     * 
     * @throws ProjectConfigException if the project configuration is invalid for writing
     */

    private void buildPortableNetworkGraphicsConsumers() throws ProjectConfigException
    {
        // Build the consumers conditionally
        if ( writeWhenTrue.test( MetricOutputGroup.MULTIVECTOR, DestinationType.PNG ) )
        {
            diagramConsumers.put( DestinationType.PNG,
                                  PNGDiagramWriter.of( projectConfigPlus ) );
        }

        if ( writeWhenTrue.test( MetricOutputGroup.BOXPLOT, DestinationType.PNG ) )
        {
            boxPlotConsumers.put( DestinationType.PNG,
                                  PNGBoxPlotWriter.of( projectConfigPlus ) );
        }

        if ( writeWhenTrue.test( MetricOutputGroup.PAIRED, DestinationType.PNG ) )
        {
            pairedConsumers.put( DestinationType.PNG,
                                 PNGPairedWriter.of( projectConfigPlus ) );
        }

        if ( writeWhenTrue.test( MetricOutputGroup.DOUBLE_SCORE, DestinationType.PNG ) )
        {
            doubleScoreConsumers.put( DestinationType.PNG,
                                      PNGDoubleScoreWriter.of( projectConfigPlus ) );
        }

        if ( writeWhenTrue.test( MetricOutputGroup.DURATION_SCORE, DestinationType.PNG ) )
        {
            durationScoreConsumers.put( DestinationType.PNG,
                                        PNGDurationScoreWriter.of( projectConfigPlus ) );
        }
    }


    /**
     * Builds a set of consumers for writing NetCDF output.
     * 
     * @param sharedWriters an optional set of shared writers to use when consuming NetCDF
     * @throws IOException when creation or mutation of netcdf files fails
     */

    private void buildNetCDFConsumers( SharedWriters sharedWriters )
            throws IOException
    {
        // Build the consumers conditionally

        // Register consumers for the NetCDF output type
        if ( writeWhenTrue.test( MetricOutputGroup.DOUBLE_SCORE, DestinationType.NETCDF ) )
        {
            // Use a shared writer
            if ( Objects.nonNull( sharedWriters )
                 && sharedWriters.contains( MetricOutputGroup.DOUBLE_SCORE, DestinationType.NETCDF ) )
            {
                doubleScoreConsumers.put( DestinationType.NETCDF,
                                          sharedWriters.getNetcdfDoubleScoreWriter() );
            }
            // Build a writer
            else
            {
                doubleScoreConsumers.put( DestinationType.NETCDF,
                                          ConfigHelper.getNetcdfDoubleScoreWriter( this.projectConfig ) );
            }
        }
    }


    /**
     * Processes {@link MultiVectorOutput}.
     * 
     * @param outputs the outputs to consume
     * @throws IOException if the output could not be consumed
     * @throws NullPointerException if the input is null
     */

    private void processDiagramOutputs( MetricOutputMultiMapByTimeAndThreshold<MultiVectorOutput> outputs )
            throws IOException
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Metadata for logging
        MetricOutputMetadata meta =
                outputs.values().iterator().next().getMetadata();

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<MetricOutputMultiMapByTimeAndThreshold<MultiVectorOutput>>> next : diagramConsumers.entrySet() )
        {
            // Consume conditionally
            if ( writeWhenTrue.test( MetricOutputGroup.MULTIVECTOR, next.getKey() ) )
            {
                log( meta, next.getKey(), true );

                // Consume the output
                next.getValue().accept( outputs );

                log( meta, next.getKey(), false );
            }
        }
    }

    /**
     * Processes {@link BoxPlotOutput}.
     * 
     * @param outputs the output to consume
     * @throws IOException if the output could not be consumed
     * @throws NullPointerException if the input is null
     */

    private void processBoxPlotOutputs( MetricOutputMultiMapByTimeAndThreshold<BoxPlotOutput> outputs )
            throws IOException
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Metadata for logging
        MetricOutputMetadata meta =
                outputs.values().iterator().next().getMetadata();

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<MetricOutputMultiMapByTimeAndThreshold<BoxPlotOutput>>> next : boxPlotConsumers.entrySet() )
        {
            // Consume conditionally
            if ( writeWhenTrue.test( MetricOutputGroup.BOXPLOT, next.getKey() ) )
            {
                log( meta, next.getKey(), true );

                // Consume the output
                next.getValue().accept( outputs );

                log( meta, next.getKey(), false );
            }
        }
    }

    /**
     * Processes {@link MatrixOutput}.
     * 
     * @param outputs the output to consume
     * @throws IOException if the output could not be consumed
     * @throws NullPointerException if the input is null
     */

    private void processMatrixOutputs( MetricOutputMultiMapByTimeAndThreshold<MatrixOutput> outputs )
            throws IOException
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Metadata for logging
        MetricOutputMetadata meta =
                outputs.values().iterator().next().getMetadata();

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<MetricOutputMultiMapByTimeAndThreshold<MatrixOutput>>> next : matrixConsumers.entrySet() )
        {
            // Consume conditionally
            if ( writeWhenTrue.test( MetricOutputGroup.MATRIX, next.getKey() ) )
            {
                log( meta, next.getKey(), true );

                // Consume the output
                next.getValue().accept( outputs );

                log( meta, next.getKey(), false );
            }
        }

    }

    /**
     * Processes {@link DoubleScoreOutput}.
     * 
     * @param outputs the output to consume
     * @throws IOException if the output could not be consumed
     * @throws NullPointerException if the input is null
     */

    private void processDoubleScoreOutputs( MetricOutputMultiMapByTimeAndThreshold<DoubleScoreOutput> outputs )
            throws IOException
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Metadata for logging
        MetricOutputMetadata meta =
                outputs.values().iterator().next().getMetadata();

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<MetricOutputMultiMapByTimeAndThreshold<DoubleScoreOutput>>> next : doubleScoreConsumers.entrySet() )
        {
            // Consume conditionally
            if ( writeWhenTrue.test( MetricOutputGroup.DOUBLE_SCORE, next.getKey() ) )
            {
                log( meta, next.getKey(), true );

                // Consume the output
                next.getValue().accept( outputs );

                log( meta, next.getKey(), false );
            }
        }

    }

    /**
     * Processes {@link DurationScoreOutput}.
     * 
     * @param outputs the output to consume
     * @throws IOException if the output could not be consumed
     * @throws NullPointerException if the input is null
     */

    private void processDurationScoreOutputs( MetricOutputMultiMapByTimeAndThreshold<DurationScoreOutput> outputs )
            throws IOException
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Metadata for logging
        MetricOutputMetadata meta =
                outputs.values().iterator().next().getMetadata();

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<MetricOutputMultiMapByTimeAndThreshold<DurationScoreOutput>>> next : durationScoreConsumers.entrySet() )
        {
            // Consume conditionally
            if ( writeWhenTrue.test( MetricOutputGroup.DURATION_SCORE, next.getKey() ) )
            {
                log( meta, next.getKey(), true );

                // Consume the output
                next.getValue().accept( outputs );

                log( meta, next.getKey(), false );
            }
        }
    }

    /**
     * Processes {@link PairedOutput}.
     * 
     * @param outputs the output to consume
     * @throws IOException if the output could not be consumed
     * @throws NullPointerException if the input is null
     */

    private void
            processPairedOutputByInstantDuration( MetricOutputMultiMapByTimeAndThreshold<PairedOutput<Instant, Duration>> outputs )
                    throws IOException
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Metadata for logging
        MetricOutputMetadata meta =
                outputs.values().iterator().next().getMetadata();

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<MetricOutputMultiMapByTimeAndThreshold<PairedOutput<Instant, Duration>>>> next : pairedConsumers.entrySet() )
        {
            // Consume conditionally
            if ( writeWhenTrue.test( MetricOutputGroup.PAIRED, next.getKey() ) )
            {
                log( meta, next.getKey(), true );

                // Consume the output
                next.getValue().accept( outputs );

                log( meta, next.getKey(), false );
            }
        }
    }

    /**
     * Returns true if the project configuration has one or more of the given types
     * 
     * @param type the type of output to look for
     * @return true if the output type is present, false otherwise
     */

    private boolean configNeedsThisTypeOfOutput( DestinationType type )
    {
        Outputs output = projectConfig.getOutputs();
        if ( Objects.isNull( output ) || output.getDestination().isEmpty() )
        {
            LOGGER.debug( "No destinations specified for config {}", projectConfig );
            return false;
        }

        // Interpret default types for graphic and numeric
        Set<DestinationType> allTypes = new HashSet<>();
        allTypes.add( type );
        if ( type == DestinationType.PNG )
        {
            allTypes.add( DestinationType.GRAPHIC );
        }
        if ( type == DestinationType.CSV )
        {
            allTypes.add( DestinationType.NUMERIC );
        }
        // Return true if any destination types appear in allTypes, otherwise false
        return output.getDestination().stream().map( DestinationConfig::getType ).anyMatch( allTypes::contains );
    }

    /**
     * Logs the status of product generation.
     * 
     * @param meta the metadata to assist with logging
     * @param type the output type
     * @param startOfProcess is true to log the start, false to log the end
     */

    private void log( MetricOutputMetadata meta, DestinationType type, boolean startOfProcess )
    {

        String positionString = "Completed ";
        if ( startOfProcess )
        {
            positionString = "Started ";
        }

        if ( Objects.nonNull( meta ) )
        {
            LOGGER.debug( "{} processing of result type '{}' for '{}' "
                          + "at time window {}.",
                          positionString,
                          type,
                          meta.getIdentifier(),
                          meta.getTimeWindow() );
        }
        else
        {
            LOGGER.debug( "{} processing of result type '{}' for unknown data at "
                          + "unknown time window.",
                          positionString,
                          type );
        }
    }


    /**
     * @return the project config
     */

    private ProjectConfig getProjectConfig()
    {
        return this.projectConfig;
    }
}
