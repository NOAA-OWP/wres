package wres.control;

import java.io.Closeable;
import java.io.IOException;
import java.nio.file.Path;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.function.Supplier;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import wres.config.ProjectConfigException;
import wres.config.ProjectConfigPlus;
import wres.config.generated.DestinationConfig;
import wres.config.generated.DestinationType;
import wres.config.generated.ProjectConfig;
import wres.config.generated.ProjectConfig.Outputs;
import wres.datamodel.MetricConstants.StatisticGroup;
import wres.datamodel.statistics.BoxPlotStatistics;
import wres.datamodel.statistics.DoubleScoreStatistic;
import wres.datamodel.statistics.DurationScoreStatistic;
import wres.datamodel.statistics.ListOfStatistics;
import wres.datamodel.statistics.MatrixStatistic;
import wres.datamodel.statistics.MultiVectorStatistic;
import wres.datamodel.statistics.PairedStatistic;
import wres.datamodel.statistics.Statistic;
import wres.datamodel.statistics.StatisticsForProject;
import wres.io.writing.SharedStatisticsWriters;
import wres.io.writing.commaseparated.statistics.CommaSeparatedBoxPlotWriter;
import wres.io.writing.commaseparated.statistics.CommaSeparatedDiagramWriter;
import wres.io.writing.commaseparated.statistics.CommaSeparatedMatrixWriter;
import wres.io.writing.commaseparated.statistics.CommaSeparatedPairedWriter;
import wres.io.writing.commaseparated.statistics.CommaSeparatedScoreWriter;
import wres.io.writing.netcdf.NetcdfOutputWriter;
import wres.io.writing.png.PNGBoxPlotWriter;
import wres.io.writing.png.PNGDiagramWriter;
import wres.io.writing.png.PNGDoubleScoreWriter;
import wres.io.writing.png.PNGDurationScoreWriter;
import wres.io.writing.png.PNGPairedWriter;

/**
 * <p>A processor that consumes statistics and produces outputs. Outputs are generated by registering instances of 
 * {@link Consumer} for particular types output formats and statistical data. The consumers are stored by 
 * {@link StatisticGroup}, i.e. by type of statistical data. Each store contains the consumers for any formats of output 
 * required, i.e. any {@link DestinationType}.</p>
 * 
 * <p>Outputs may be written unconditionally, for all types and formats available, or conditionally, for specific 
 * combinations of data type and format. Conditional writing is determined on construction with a {@link BiPredicate} 
 * condition on {@link StatisticGroup} and {@link DestinationType}.</p>.
 * 
 * @author james.brown@hydrosolved.com
 * @author jesse.bickel@***REMOVED***
 */

class ProduceOutputsFromStatistics implements Consumer<StatisticsForProject>,
        Closeable,
        Supplier<Set<Path>>
{

    /**
     * Logger.
     */

    private static final Logger LOGGER = LoggerFactory.getLogger( ProduceOutputsFromStatistics.class );

    /**
     * Null output error string
     */

    private static final String NULL_OUTPUT_STRING = "Specify non-null outputs for product generation.";

    /**
     * The resolved project configuration.
     */

    private final ResolvedProject resolvedProject;

    /**
     * Only writes when the condition is true.
     */

    private final BiPredicate<StatisticGroup, DestinationType> writeWhenTrue;

    /**
     * Store of consumers for processing {@link DoubleScoreStatistic} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<ListOfStatistics<DoubleScoreStatistic>>> doubleScoreConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link DurationScoreStatistic} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<ListOfStatistics<DurationScoreStatistic>>> durationScoreConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link MultiVectorStatistic} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<ListOfStatistics<MultiVectorStatistic>>> diagramConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link BoxPlotStatistics} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<ListOfStatistics<BoxPlotStatistics>>> boxPlotConsumersPerPair =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link BoxPlotStatistics} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<ListOfStatistics<BoxPlotStatistics>>> boxPlotConsumersPerPool =
            new EnumMap<>( DestinationType.class );
    
    /**
     * Store of consumers for processing {@link MatrixStatistic} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<ListOfStatistics<MatrixStatistic>>> matrixConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link PairedStatistic} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<ListOfStatistics<PairedStatistic<Instant, Duration>>>> pairedConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * List of resources that ProductProcessor opened that it needs to close
     */
    private final List<Closeable> resourcesToClose;

    /**
     * List of potential writers that the ProductProcessor opened that supply
     * a list of paths that those writers actually ended up writing to.
     */
    private final List<Supplier<Set<Path>>> writersToPaths;

    /**
     * Build a product processor that writes unconditionally
     *
     * @param resolvedProject the resolved project
     * @throws NullPointerException if any of the inputs are null
     * @throws WresProcessingException if the project is invalid for writing
     */

    ProduceOutputsFromStatistics( final ResolvedProject resolvedProject )
    {
        // Write unconditionally
        this( resolvedProject, ( x, y ) -> true );
    }

    /**
     * Build a product processor that writes conditionally.
     *
     * @param resolvedProject the resolved project
     * @param writeWhenTrue the condition under which outputs should be written
     * @throws NullPointerException if any of the inputs are null
     * @throws WresProcessingException if the project is invalid for writing
     */

    ProduceOutputsFromStatistics( final ResolvedProject resolvedProject,
                                  final BiPredicate<StatisticGroup, DestinationType> writeWhenTrue )
    {
        this( resolvedProject, writeWhenTrue, null );
    }

    /**
     * Build a product processor that writes conditionally.
     * 
     * @param resolvedProject the resolved project
     * @param writeWhenTrue the condition under which outputs should be written
     * @param sharedWriters an optional set of shared writers to consume outputs
     * @throws NullPointerException if any of the inputs are null
     * @throws WresProcessingException if the project is invalid for writing
     */

    ProduceOutputsFromStatistics( final ResolvedProject resolvedProject,
                                  final BiPredicate<StatisticGroup, DestinationType> writeWhenTrue,
                                  final SharedStatisticsWriters sharedWriters )
    {
        Objects.requireNonNull( resolvedProject,
                                "Specify a non-null configuration for the results processor." );

        Objects.requireNonNull( writeWhenTrue, "Specify a non-null condition to ignore." );

        this.resourcesToClose = new ArrayList<>( 1 );
        this.writersToPaths = new ArrayList<>();
        this.resolvedProject = resolvedProject;
        this.writeWhenTrue = writeWhenTrue;

        // Register output consumers
        try
        {
            // implicitly passing resolvedProject via shared state
            this.buildConsumers( sharedWriters );
        }
        catch ( ProjectConfigException e )
        {
            throw new WresProcessingException( "While processing the project configuration to write output:", e );
        }

    }

    /**
     * Produces graphical and numerical output for each type available in the input.
     * 
     * @param input the input containing results for one project
     * @throws WresProcessingException if the outputs could not be written
     */

    @Override
    public void accept( final StatisticsForProject input )
    {

        try
        {
            // Multivector output available
            if ( input.hasStatistic( StatisticGroup.MULTIVECTOR ) )
            {
                this.processDiagramOutputs( input.getMultiVectorStatistics() );
            }

            // Box-plot output available per pair
            if ( input.hasStatistic( StatisticGroup.BOXPLOT_PER_PAIR ) )
            {
                this.processBoxPlotOutputsPerPair( input.getBoxPlotStatisticsPerPair() );
            }

            // Box-plot output available per pool
            if ( input.hasStatistic( StatisticGroup.BOXPLOT_PER_POOL ) )
            {
                this.processBoxPlotOutputsPerPool( input.getBoxPlotStatisticsPerPool() );
            }
            
            // Matrix output available
            if ( input.hasStatistic( StatisticGroup.MATRIX ) )
            {
                this.processMatrixOutputs( input.getMatrixStatistics() );
            }

            // Ordinary scores available
            if ( input.hasStatistic( StatisticGroup.DOUBLE_SCORE ) )
            {
                this.processDoubleScoreOutputs( input.getDoubleScoreStatistics() );
            }

            // Duration scores available
            if ( input.hasStatistic( StatisticGroup.DURATION_SCORE ) )
            {
                this.processDurationScoreOutputs( input.getDurationScoreStatistics() );
            }

            // Paired metric output available
            if ( input.hasStatistic( StatisticGroup.PAIRED ) )
            {
                this.processPairedOutputByInstantDuration( input.getPairedStatistics() );
            }
        }
        catch ( InterruptedException e )
        {
            String message = "Interrupted while processing intermediate results:";
            Thread.currentThread().interrupt();

            throw new WresProcessingException( message, e );
        }
    }

    private List<Supplier<Set<Path>>> getWritersToPaths()
    {
        return Collections.unmodifiableList( this.writersToPaths );
    }

    /**
     * @return paths actually written to by this processor so far.
     */
    @Override
    public Set<Path> get()
    {
        Set<Path> paths = new HashSet<>();

        for ( Supplier<Set<Path>> supplierOfPaths : this.getWritersToPaths() )
        {
            paths.addAll( supplierOfPaths.get() );
        }

        LOGGER.debug( "Returning paths from ProductProcessor {}: {}", this, paths );
        return Collections.unmodifiableSet( paths );
    }

    /**
     * <p>Builds a set of consumers for writing based on the project configuration.</p>
     * 
     * <p>Edit this method as new consumer types are supported by the project configuration.</p>
     * 
     * @param sharedWriters an optional set of shared writers
     * @throws ProjectConfigException if the project configuration is invalid for writing
     */

    private void buildConsumers( SharedStatisticsWriters sharedWriters )
    {
        // There is one consumer per project for each type, because consumers are built
        // with projects, not destinations. The consumers must iterate destinations.

        // Register consumers for the NetCDF output type
        if ( this.configNeedsThisTypeOfOutput( DestinationType.NETCDF ) )
        {
            // implicitly passing resolvedProject via shared state
            this.buildNetCDFConsumers( sharedWriters );
        }

        // Register consumers for the CSV output type
        if ( this.configNeedsThisTypeOfOutput( DestinationType.CSV ) )
        {
            this.buildCommaSeparatedConsumers();
        }

        // Register consumers for the PNG output type
        if ( this.configNeedsThisTypeOfOutput( DestinationType.PNG ) )
        {
            this.buildPortableNetworkGraphicsConsumers();
        }

    }

    /**
     * Builds a set of consumers for writing files of Comma Separated Values (CSV).
     * Also builds a set of writers to ask for paths written to later.
     * 
     * @throws ProjectConfigException if the project configuration is invalid for writing
     */

    private void buildCommaSeparatedConsumers()
    {
        ProjectConfig projectConfig = this.getProjectConfig();
        Path outputDirectory = this.getResolvedProject().getOutputDirectory();

        // Build the consumers conditionally
        if ( this.writeWhenTrue.test( StatisticGroup.MULTIVECTOR, DestinationType.CSV ) )
        {
            CommaSeparatedDiagramWriter diagramWriter =
                    CommaSeparatedDiagramWriter.of( projectConfig,
                                                    ProcessorHelper.DEFAULT_TEMPORAL_UNITS,
                                                    outputDirectory );
            this.diagramConsumers.put( DestinationType.CSV,
                                       diagramWriter );
            this.writersToPaths.add( diagramWriter );
        }

        if ( this.writeWhenTrue.test( StatisticGroup.BOXPLOT_PER_PAIR, DestinationType.CSV ) )
        {
            CommaSeparatedBoxPlotWriter boxPlotWriter =
                    CommaSeparatedBoxPlotWriter.of( projectConfig,
                                                    ProcessorHelper.DEFAULT_TEMPORAL_UNITS,
                                                    outputDirectory );
            this.boxPlotConsumersPerPair.put( DestinationType.CSV,
                                       boxPlotWriter );
            this.writersToPaths.add( boxPlotWriter );
        }
        
        if ( this.writeWhenTrue.test( StatisticGroup.BOXPLOT_PER_POOL, DestinationType.CSV ) )
        {
            CommaSeparatedBoxPlotWriter boxPlotWriter =
                    CommaSeparatedBoxPlotWriter.of( projectConfig,
                                                    ProcessorHelper.DEFAULT_TEMPORAL_UNITS,
                                                    outputDirectory );
            this.boxPlotConsumersPerPool.put( DestinationType.CSV,
                                       boxPlotWriter );
            this.writersToPaths.add( boxPlotWriter );
        }

        if ( this.writeWhenTrue.test( StatisticGroup.MATRIX, DestinationType.CSV ) )
        {
            CommaSeparatedMatrixWriter matrixWriter =
                    CommaSeparatedMatrixWriter.of( projectConfig,
                                                   ProcessorHelper.DEFAULT_TEMPORAL_UNITS,
                                                   outputDirectory );
            this.matrixConsumers.put( DestinationType.CSV,
                                      matrixWriter );
            this.writersToPaths.add( matrixWriter );
        }

        if ( this.writeWhenTrue.test( StatisticGroup.PAIRED, DestinationType.CSV ) )
        {
            // Add the paths for the paired writer: #61841
            CommaSeparatedPairedWriter<Instant, Duration> pairedWriter =
                    CommaSeparatedPairedWriter.of( projectConfig,
                                                   ProcessorHelper.DEFAULT_TEMPORAL_UNITS,
                                                   outputDirectory );
            this.pairedConsumers.put( DestinationType.CSV, pairedWriter );
            this.writersToPaths.add( pairedWriter );
        }

        if ( this.writeWhenTrue.test( StatisticGroup.DOUBLE_SCORE, DestinationType.CSV ) )
        {
            CommaSeparatedScoreWriter<DoubleScoreStatistic> doubleScoreWriter =
                    CommaSeparatedScoreWriter.of( projectConfig,
                                                  ProcessorHelper.DEFAULT_TEMPORAL_UNITS,
                                                  outputDirectory );
            this.doubleScoreConsumers.put( DestinationType.CSV,
                                           doubleScoreWriter );
            this.writersToPaths.add( doubleScoreWriter );
        }

        if ( this.writeWhenTrue.test( StatisticGroup.DURATION_SCORE, DestinationType.CSV ) )
        {
            CommaSeparatedScoreWriter<DurationScoreStatistic> durationScoreWriter =
                    CommaSeparatedScoreWriter.of( projectConfig,
                                                  ProcessorHelper.DEFAULT_TEMPORAL_UNITS,
                                                  outputDirectory );
            this.durationScoreConsumers.put( DestinationType.CSV,
                                             durationScoreWriter );
            this.writersToPaths.add( durationScoreWriter );
        }
    }

    /**
     * Builds a set of consumers for writing files in Portable Network Graphics (PNG) format.
     *
     * @throws ProjectConfigException if the project configuration is invalid for writing
     */

    private void buildPortableNetworkGraphicsConsumers()
    {
        ProjectConfigPlus projectConfigPlus = this.getProjectConfigPlus();
        Path outputDirectory = this.getResolvedProject().getOutputDirectory();

        // Build the consumers conditionally
        if ( this.writeWhenTrue.test( StatisticGroup.MULTIVECTOR, DestinationType.PNG ) )
        {
            PNGDiagramWriter diagramWriter = PNGDiagramWriter.of( projectConfigPlus,
                                                                  ProcessorHelper.DEFAULT_TEMPORAL_UNITS,
                                                                  outputDirectory );
            this.diagramConsumers.put( DestinationType.PNG,
                                       diagramWriter );
            this.writersToPaths.add( diagramWriter );
        }

        if ( this.writeWhenTrue.test( StatisticGroup.BOXPLOT_PER_PAIR, DestinationType.PNG ) )
        {
            PNGBoxPlotWriter boxPlotWriter = PNGBoxPlotWriter.of( projectConfigPlus,
                                                                  ProcessorHelper.DEFAULT_TEMPORAL_UNITS,
                                                                  outputDirectory );
            this.boxPlotConsumersPerPair.put( DestinationType.PNG,
                                       boxPlotWriter );
            this.writersToPaths.add( boxPlotWriter );
        }
        
        if ( this.writeWhenTrue.test( StatisticGroup.BOXPLOT_PER_POOL, DestinationType.PNG ) )
        {
            PNGBoxPlotWriter boxPlotWriter = PNGBoxPlotWriter.of( projectConfigPlus,
                                                                  ProcessorHelper.DEFAULT_TEMPORAL_UNITS,
                                                                  outputDirectory );
            this.boxPlotConsumersPerPool.put( DestinationType.PNG,
                                              boxPlotWriter );
            this.writersToPaths.add( boxPlotWriter );
        }

        if ( this.writeWhenTrue.test( StatisticGroup.PAIRED, DestinationType.PNG ) )
        {
            PNGPairedWriter pairedWriter = PNGPairedWriter.of( projectConfigPlus,
                                                               ProcessorHelper.DEFAULT_TEMPORAL_UNITS,
                                                               outputDirectory );
            this.pairedConsumers.put( DestinationType.PNG,
                                      pairedWriter );
            this.writersToPaths.add( pairedWriter );
        }

        if ( this.writeWhenTrue.test( StatisticGroup.DOUBLE_SCORE, DestinationType.PNG ) )
        {
            PNGDoubleScoreWriter doubleScoreWriter =
                    PNGDoubleScoreWriter.of( projectConfigPlus,
                                             ProcessorHelper.DEFAULT_TEMPORAL_UNITS,
                                             outputDirectory );
            this.doubleScoreConsumers.put( DestinationType.PNG,
                                           doubleScoreWriter );
            this.writersToPaths.add( doubleScoreWriter );
        }

        if ( this.writeWhenTrue.test( StatisticGroup.DURATION_SCORE, DestinationType.PNG ) )
        {
            PNGDurationScoreWriter durationScoreWriter =
                    PNGDurationScoreWriter.of( projectConfigPlus,
                                               ProcessorHelper.DEFAULT_TEMPORAL_UNITS,
                                               outputDirectory );
            this.durationScoreConsumers.put( DestinationType.PNG,
                                             durationScoreWriter );
            this.writersToPaths.add( durationScoreWriter );
        }

    }

    private void buildNetCDFConsumers( SharedStatisticsWriters sharedWriters )
    {
        ProjectConfig projectConfig = this.getProjectConfigPlus().getProjectConfig();

        // Build the consumers conditionally
        if ( Objects.nonNull( sharedWriters )
             && sharedWriters.contains( StatisticGroup.DOUBLE_SCORE, DestinationType.NETCDF ) )
        {
            LOGGER.debug( "There are shared netcdf consumers for {}", this );
            this.doubleScoreConsumers.put( DestinationType.NETCDF,
                                           sharedWriters );
            this.writersToPaths.add( sharedWriters );
            // Not in charge of closing the sharedwriters, that is out at top.
        }
        else if ( this.writeWhenTrue.test( StatisticGroup.DOUBLE_SCORE, DestinationType.NETCDF ) )
        {
            LOGGER.debug( "There are netcdf consumers for {}", this );
            NetcdfOutputWriter netcdfOutputWriter = NetcdfOutputWriter.of( projectConfig,
                                                                           ProcessorHelper.DEFAULT_TEMPORAL_UNITS,
                                                                           this.getResolvedProject()
                                                                               .getOutputDirectory() );
            doubleScoreConsumers.put( DestinationType.NETCDF,
                                      netcdfOutputWriter );
            this.writersToPaths.add( netcdfOutputWriter );
            this.resourcesToClose.add( netcdfOutputWriter );
        }
        else
        {
            LOGGER.debug( "There are NOT netcdf consumers for {}", this );
        }
    }


    /**
     * Processes {@link MultiVectorStatistic}.
     * 
     * @param outputs the outputs to consume
     * @throws NullPointerException if the input is null
     */

    private void processDiagramOutputs( ListOfStatistics<MultiVectorStatistic> outputs )
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<ListOfStatistics<MultiVectorStatistic>>> next : this.diagramConsumers.entrySet() )
        {
            // Consume conditionally
            if ( this.writeWhenTrue.test( StatisticGroup.MULTIVECTOR, next.getKey() ) )
            {
                log( outputs, next.getKey(), true );

                // Consume the output
                next.getValue().accept( outputs );

                log( outputs, next.getKey(), false );
            }
        }
    }

    /**
     * Processes {@link BoxPlotStatistics} per pair.
     * 
     * @param outputs the output to consume
     * @throws NullPointerException if the input is null
     */

    private void processBoxPlotOutputsPerPair( ListOfStatistics<BoxPlotStatistics> outputs )
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<ListOfStatistics<BoxPlotStatistics>>> next : this.boxPlotConsumersPerPair.entrySet() )
        {
            // Consume conditionally
            if ( this.writeWhenTrue.test( StatisticGroup.BOXPLOT_PER_PAIR, next.getKey() ) )
            {
                log( outputs, next.getKey(), true );

                // Consume the output
                next.getValue().accept( outputs );

                log( outputs, next.getKey(), false );
            }
        }
    }

    /**
     * Processes {@link BoxPlotStatistics} per pool.
     * 
     * @param outputs the output to consume
     * @throws NullPointerException if the input is null
     */

    private void processBoxPlotOutputsPerPool( ListOfStatistics<BoxPlotStatistics> outputs )
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<ListOfStatistics<BoxPlotStatistics>>> next : this.boxPlotConsumersPerPool.entrySet() )
        {
            // Consume conditionally
            if ( this.writeWhenTrue.test( StatisticGroup.BOXPLOT_PER_POOL, next.getKey() ) )
            {
                log( outputs, next.getKey(), true );

                // Consume the output
                next.getValue().accept( outputs );

                log( outputs, next.getKey(), false );
            }
        }
    }
    
    /**
     * Processes {@link MatrixStatistic}.
     * 
     * @param outputs the output to consume
     * @throws NullPointerException if the input is null
     */

    private void processMatrixOutputs( ListOfStatistics<MatrixStatistic> outputs )
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<ListOfStatistics<MatrixStatistic>>> next : this.matrixConsumers.entrySet() )
        {
            // Consume conditionally
            if ( this.writeWhenTrue.test( StatisticGroup.MATRIX, next.getKey() ) )
            {
                log( outputs, next.getKey(), true );

                // Consume the output
                next.getValue().accept( outputs );

                log( outputs, next.getKey(), false );
            }
        }

    }

    /**
     * Processes {@link DoubleScoreStatistic}.
     * 
     * @param outputs the output to consume
     * @throws NullPointerException if the input is null
     */

    private void processDoubleScoreOutputs( ListOfStatistics<DoubleScoreStatistic> outputs )
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<ListOfStatistics<DoubleScoreStatistic>>> next : this.doubleScoreConsumers.entrySet() )
        {
            // Consume conditionally
            if ( this.writeWhenTrue.test( StatisticGroup.DOUBLE_SCORE, next.getKey() ) )
            {
                log( outputs, next.getKey(), true );

                // Consume the output
                next.getValue().accept( outputs );

                log( outputs, next.getKey(), false );
            }
        }

    }

    /**
     * Processes {@link DurationScoreStatistic}.
     * 
     * @param outputs the output to consume
     * @throws NullPointerException if the input is null
     */

    private void processDurationScoreOutputs( ListOfStatistics<DurationScoreStatistic> outputs )
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<ListOfStatistics<DurationScoreStatistic>>> next : this.durationScoreConsumers.entrySet() )
        {
            // Consume conditionally
            if ( this.writeWhenTrue.test( StatisticGroup.DURATION_SCORE, next.getKey() ) )
            {
                log( outputs, next.getKey(), true );

                // Consume the output
                next.getValue().accept( outputs );

                log( outputs, next.getKey(), false );
            }
        }
    }

    /**
     * Processes {@link PairedStatistic}.
     * 
     * @param outputs the output to consume
     * @throws NullPointerException if the input is null
     */

    private void
            processPairedOutputByInstantDuration( ListOfStatistics<PairedStatistic<Instant, Duration>> outputs )
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<ListOfStatistics<PairedStatistic<Instant, Duration>>>> next : this.pairedConsumers.entrySet() )
        {
            // Consume conditionally
            if ( this.writeWhenTrue.test( StatisticGroup.PAIRED, next.getKey() ) )
            {
                log( outputs, next.getKey(), true );

                // Consume the output
                next.getValue().accept( outputs );

                log( outputs, next.getKey(), false );
            }
        }
    }

    /**
     * Returns true if the project configuration has one or more of the given types
     * 
     * @param type the type of output to look for
     * @return true if the output type is present, false otherwise
     */

    private boolean configNeedsThisTypeOfOutput( DestinationType type )
    {
        ProjectConfig projectConfig = this.getProjectConfig();
        Outputs output = projectConfig.getOutputs();
        if ( Objects.isNull( output ) || output.getDestination().isEmpty() )
        {
            LOGGER.debug( "No destinations specified for config {}", projectConfig );
            return false;
        }

        // Interpret default types for graphic and numeric
        Set<DestinationType> allTypes = new HashSet<>();
        allTypes.add( type );
        if ( type == DestinationType.PNG )
        {
            allTypes.add( DestinationType.GRAPHIC );
        }
        if ( type == DestinationType.CSV )
        {
            allTypes.add( DestinationType.NUMERIC );
        }
        // Return true if any destination types appear in allTypes, otherwise false
        return output.getDestination().stream().map( DestinationConfig::getType ).anyMatch( allTypes::contains );
    }


    /**
     * Closes resources that were opened by this class.
     */

    @Override
    public void close()
    {
        for ( Closeable resource : this.resourcesToClose )
        {
            LOGGER.debug( "About to close {}", resource );

            try
            {
                resource.close();
            }
            catch ( IOException ioe )
            {
                // Not much we can do at this point. We tried to close, but
                // we need to try to close all the other resources too before
                // the software exits.
                LOGGER.warn( "Unable to close resource {}", resource, ioe );
            }
        }
    }


    /**
     * Logs the status of product generation.
     * 
     * @param <T> the output type
     * @param output the output
     * @param type the output type
     * @param startOfProcess is true to log the start, false to log the end
     */

    private <T extends Statistic<?>> void
            log( ListOfStatistics<T> output, DestinationType type, boolean startOfProcess )
    {

        String positionString = "Completed ";
        if ( startOfProcess )
        {
            positionString = "Started ";
        }

        if ( !output.getData().isEmpty() )
        {
            LOGGER.debug( "{} processing of result type '{}' for '{}' "
                          + "at time window {}.",
                          positionString,
                          type,
                          output.getData().get( 0 ).getMetadata().getSampleMetadata().getIdentifier(),
                          output.getData().get( 0 ).getMetadata().getSampleMetadata().getTimeWindow() );
        }
        else
        {
            LOGGER.debug( "{} processing of result type '{}' for unknown data at "
                          + "unknown time window.",
                          positionString,
                          type );
        }
    }


    /**
     * @return the resolved project
     */

    private ResolvedProject getResolvedProject()
    {
        return this.resolvedProject;
    }

    /**
     * @return the project config with more (2nd order project config)
     */

    private ProjectConfigPlus getProjectConfigPlus()
    {
        return this.getResolvedProject()
                   .getProjectConfigPlus();
    }

    /**
     * @return the project config
     */

    private ProjectConfig getProjectConfig()
    {
        return this.getResolvedProject()
                   .getProjectConfig();
    }
}
