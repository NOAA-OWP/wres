package wres.control;

import java.io.Closeable;
import java.io.IOException;
import java.nio.file.Path;
import java.text.Format;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import wres.config.ProjectConfigException;
import wres.config.ProjectConfigPlus;
import wres.config.ProjectConfigs;
import wres.config.generated.DestinationConfig;
import wres.config.generated.DestinationType;
import wres.config.generated.GraphicalType;
import wres.config.generated.LeftOrRightOrBaseline;
import wres.config.generated.MetricConfigName;
import wres.config.generated.ProjectConfig;
import wres.datamodel.MetricConstants;
import wres.datamodel.MetricConstants.StatisticType;
import wres.datamodel.messages.MessageFactory;
import wres.datamodel.sampledata.SampleMetadata;
import wres.datamodel.Slicer;
import wres.datamodel.statistics.BoxplotStatisticOuter;
import wres.datamodel.statistics.DoubleScoreStatisticOuter;
import wres.datamodel.statistics.DoubleScoreStatisticOuter.DoubleScoreComponentOuter;
import wres.datamodel.statistics.DurationScoreStatisticOuter;
import wres.datamodel.statistics.DurationScoreStatisticOuter.DurationScoreComponentOuter;
import wres.datamodel.statistics.DiagramStatisticOuter;
import wres.datamodel.statistics.DurationDiagramStatisticOuter;
import wres.datamodel.statistics.Statistic;
import wres.engine.statistics.metric.config.MetricConfigHelper;
import wres.events.ConsumerException;
import wres.io.config.ConfigHelper;
import wres.io.writing.SharedStatisticsWriters;
import wres.io.writing.commaseparated.statistics.CommaSeparatedBoxPlotWriter;
import wres.io.writing.commaseparated.statistics.CommaSeparatedDiagramWriter;
import wres.io.writing.commaseparated.statistics.CommaSeparatedDurationDiagramWriter;
import wres.io.writing.commaseparated.statistics.CommaSeparatedScoreWriter;
import wres.statistics.generated.DiagramStatistic;
import wres.statistics.generated.BoxplotStatistic;
import wres.statistics.generated.Evaluation;
import wres.statistics.generated.Outputs;
import wres.statistics.generated.Pool;
import wres.statistics.generated.Statistics;
import wres.statistics.generated.DoubleScoreStatistic;
import wres.statistics.generated.DurationScoreStatistic;
import wres.statistics.generated.DurationDiagramStatistic;
import wres.vis.writing.BoxPlotGraphicsWriter;
import wres.vis.writing.DiagramGraphicsWriter;
import wres.vis.writing.DoubleScoreGraphicsWriter;
import wres.vis.writing.DurationDiagramGraphicsWriter;
import wres.vis.writing.DurationScoreGraphicsWriter;

/**
 * <p>A processor that consumes statistics and produces outputs. Outputs are generated by registering instances of 
 * {@link Consumer} for particular types output formats and statistical data. The consumers are stored by 
 * {@link StatisticType}, i.e. by type of statistical data. Each store contains the consumers for any formats of output 
 * required, i.e. any {@link DestinationType}.</p>
 * 
 * <p>Outputs may be written unconditionally, for all types and formats available, or conditionally, for specific 
 * combinations of data type and format. Conditional writing is determined on construction with a {@link BiPredicate} 
 * condition on {@link StatisticType} and {@link DestinationType}.</p>.
 * 
 * <p>TODO: break apart this large consumer into separate consumers for each output format. Eventually, these consumers
 * should be implemented in their own microservices.
 * 
 * @author james.brown@hydrosolved.com
 * @author jesse.bickel@***REMOVED***
 */

class StatisticsConsumer implements Consumer<Collection<Statistics>>, Closeable, Supplier<Set<Path>>
{

    /**
     * Logger.
     */

    private static final Logger LOGGER = LoggerFactory.getLogger( StatisticsConsumer.class );

    /**
     * Null output error string
     */

    private static final String NULL_OUTPUT_STRING = "Specify non-null outputs for product generation.";

    /**
     * Only writes when the condition is true.
     */

    private final BiPredicate<StatisticType, DestinationType> writeWhenTrue;

    /**
     * Store of consumers for processing {@link DoubleScoreStatisticOuter} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<List<DoubleScoreStatisticOuter>>> doubleScoreConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link DurationScoreStatisticOuter} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<List<DurationScoreStatisticOuter>>> durationScoreConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link DiagramStatisticOuter} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<List<DiagramStatisticOuter>>> diagramConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link BoxplotStatisticOuter} by {@link DestinationType} format. The plots
     * contain one box per pair.
     */

    private final Map<DestinationType, Consumer<List<BoxplotStatisticOuter>>> boxPlotConsumersPerPair =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link BoxplotStatisticOuter} by {@link DestinationType} format. The plots
     * contain one box per pool.
     */

    private final Map<DestinationType, Consumer<List<BoxplotStatisticOuter>>> boxPlotConsumersPerPool =
            new EnumMap<>( DestinationType.class );

    /**
     * Store of consumers for processing {@link DiagramDiagramStatisticOuter} by {@link DestinationType} format.
     */

    private final Map<DestinationType, Consumer<List<DurationDiagramStatisticOuter>>> pairedConsumers =
            new EnumMap<>( DestinationType.class );

    /**
     * Writers that consume all types of statistics.
     */

    private final Set<Consumer<Statistics>> statisticsConsumers = new HashSet<>();

    /**
     * A map of output formats for which specific metrics should not be written. 
     */

    private final Map<DestinationType, Set<MetricConstants>> suppressTheseDestinationsForTheseMetrics;

    /**
     * List of resources that ProductProcessor opened that it needs to close
     */
    private final List<Closeable> resourcesToClose;

    /**
     * List of potential writers that the ProductProcessor opened that supply
     * a list of paths that those writers actually ended up writing to.
     */
    private final List<Supplier<Set<Path>>> writersToPaths;

    /**
     * The duration units.
     */

    private final ChronoUnit durationUnits;

    /**
     * The evaluation description.
     */

    private final Evaluation evaluationDescription;

    /**
     * The wrapped project declaration.
     */

    private final ProjectConfigPlus projectConfigPlus;

    /**
     * The output directory.
     */

    private final Path outputDirectory;

    /**
     * Build the consumer.
     * 
     * TODO: when abstracting consumers from the core of wres to their own subscribers that run in separate processes,
     * the output path for writing will need to be packaged in the AMQP metadata. The system settings will disappear 
     * too; currently, this is only used to propagate chart width/height to the PNG writers. Those preferences should 
     * either be part of the subscriber service configuration or the AMQP message metadata.
     * 
     * @param evaluationDescription the evaluation description
     * @param projectConfigPlus the wrapped project declaration
     * @param writeWhenTrue the condition under which outputs should be written
     * @param sharedWriters an optional set of shared writers to consume outputs
     * @param outputDirectory the output directory
     * @throws NullPointerException if any of the inputs are null
     * @throws WresProcessingException if the project is invalid for writing
     */

    static StatisticsConsumer of( Evaluation evaluationDescription,
                                  ProjectConfigPlus projectConfigPlus,
                                  BiPredicate<StatisticType, DestinationType> writeWhenTrue,
                                  SharedStatisticsWriters sharedWriters,
                                  Path outputDirectory )
    {
        return new StatisticsConsumer( evaluationDescription,
                                       projectConfigPlus,
                                       writeWhenTrue,
                                       sharedWriters,
                                       outputDirectory );
    }

    /**
     * Produces graphical and numerical output for each type available in the input.
     * 
     * @param statistics the list of statistics
     * @throws ConsumerException if consumption fails for any reason
     */

    @Override
    public void accept( Collection<Statistics> statistics )
    {
        if ( Objects.isNull( statistics ) )
        {
            throw new ConsumerException( "Cannot consumer null statistics." );
        }

        try
        {
            // Split the statistics into two groups as there may be separate statistics for a baseline
            Function<? super Statistics, ? extends LeftOrRightOrBaseline> classifier = statistic -> {
                if ( !statistic.hasPool() && statistic.hasBaselinePool() )
                {
                    return LeftOrRightOrBaseline.BASELINE;
                }

                return LeftOrRightOrBaseline.RIGHT;
            };

            Map<LeftOrRightOrBaseline, List<Statistics>> groups =
                    statistics.stream()
                              .collect( Collectors.groupingBy( classifier ) );

            // Iterate the types
            groups.forEach( ( ( a, b ) -> this.acceptInner( b, a == LeftOrRightOrBaseline.BASELINE ) ) );
        }
        // Better to throw a common type here as a JMS MessageListener is expected to handle all exceptions
        // and it is better to aggregate them into one type than to catch a generic java.lang.Exception in 
        // a MessageListener. It is possible that other types could occur, which could make the application
        // hang on failing to consume all expected messages. This only applies to internal consumers that 
        // can break the flow with exceptions. Eventually, all consumers will be external. 
        catch ( RuntimeException e )
        {
            throw new ConsumerException( "While consuming evaluation statistics.", e );
        }
    }

    /**
     * Accept some statistics for consumption.
     * @param statistics the statistics
     * @param isBaselinePool is true if the statistics refer to a baseline pool (when generating separate statistics 
     *            for both a main pool and baseline pool).
     * @throws NullPointerException if the statistics are null
     */

    public void acceptInner( Collection<Statistics> statistics, boolean isBaselinePool )
    {
        Objects.requireNonNull( statistics );

        // Supplies the pool metadata from either the baseline pool or the main pool
        Function<Statistics, Pool> poolSupplier = statistic -> {
            if ( isBaselinePool )
            {
                return statistic.getBaselinePool();
            }
            return statistic.getPool();
        };

        // Diagram output available
        if ( statistics.stream().anyMatch( next -> next.getDiagramsCount() > 0 ) )
        {
            List<DiagramStatisticOuter> wrapped = this.getWrappedAndSortedStatistics( statistics,
                                                                                      this.getDiagramMapper( poolSupplier ) );
            this.processDiagramOutputs( wrapped );
        }

        // Box-plot output available per pair
        if ( statistics.stream().anyMatch( next -> next.getOneBoxPerPairCount() > 0 ) )
        {
            Function<Statistics, List<BoxplotStatistic>> supplier = Statistics::getOneBoxPerPairList;
            List<BoxplotStatisticOuter> wrapped = this.getWrappedAndSortedStatistics( statistics,
                                                                                      this.getBoxplotMapper( supplier,
                                                                                                             poolSupplier ) );
            this.processBoxPlotOutputsPerPair( wrapped );
        }

        // Box-plot output available per pool
        if ( statistics.stream().anyMatch( next -> next.getOneBoxPerPoolCount() > 0 ) )
        {
            Function<Statistics, List<BoxplotStatistic>> supplier = Statistics::getOneBoxPerPoolList;
            List<BoxplotStatisticOuter> wrapped = this.getWrappedAndSortedStatistics( statistics,
                                                                                      this.getBoxplotMapper( supplier,
                                                                                                             poolSupplier ) );

            this.processBoxPlotOutputsPerPool( wrapped );
        }

        // Ordinary scores available
        if ( statistics.stream().anyMatch( next -> next.getScoresCount() > 0 ) )
        {
            List<DoubleScoreStatisticOuter> wrapped = this.getWrappedAndSortedStatistics( statistics,
                                                                                          this.getDoubleScoreMapper( poolSupplier ) );

            this.processDoubleScoreOutputs( wrapped );
        }

        // Duration scores available
        if ( statistics.stream().anyMatch( next -> next.getDurationScoresCount() > 0 ) )
        {
            List<DurationScoreStatisticOuter> wrapped = this.getWrappedAndSortedStatistics( statistics,
                                                                                            this.getDurationScoreMapper( poolSupplier ) );

            this.processDurationScoreOutputs( wrapped );
        }

        // Duration diagrams available
        if ( statistics.stream().anyMatch( next -> next.getDurationDiagramsCount() > 0 ) )
        {
            List<DurationDiagramStatisticOuter> wrapped = this.getWrappedAndSortedStatistics( statistics,
                                                                                              this.getDurationDiagramMapper( poolSupplier ) );

            this.processDurationDiagramStatistic( wrapped );
        }

        // Consumers of all statistics
        if ( !this.statisticsConsumers.isEmpty() )
        {
            this.processMultiStatistics( statistics );
        }
    }

    /**
     * <p>Returns wrapped statistics from unwrapped statistics. Additionally sort the statistics by time window and 
     * threshold. a
     *
     * <p>Some of the existing consumers, notably the PNG consumers, currently assume that the statistics are sorted. 
     * The consumers should probably not make this assumption, else it should be clear in the API.
     * 
     * @param <W> the wrapped statistic type
     * @param statistics the statistics
     * @param mapper the supplier of unwrapped statistics from a bucket of many types
     * @return the wrapped and sorted statistics 
     */

    private <W extends Statistic<?>> List<W> getWrappedAndSortedStatistics( Collection<Statistics> statistics,
                                                                            Function<Statistics, List<W>> mapper )
    {
        List<W> wrapped = statistics.stream()
                                    .map( mapper )
                                    .flatMap( List::stream )
                                    .collect( Collectors.toUnmodifiableList() );

        return Slicer.sortByTimeWindowAndThreshold( wrapped );
    }

    /**
     * Returns a mapper function that maps between raw statistics and wrapped diagrams.
     * 
     * @param poolSupplier the pool supplier
     * @return the mapper
     */

    private Function<Statistics, List<DiagramStatisticOuter>>
            getDiagramMapper( Function<Statistics, Pool> poolSupplier )
    {
        return someStats -> {
            List<DiagramStatistic> diagrams = someStats.getDiagramsList();
            Function<DiagramStatistic, DiagramStatisticOuter> innerMapper =
                    nextDiagram -> DiagramStatisticOuter.of( nextDiagram,
                                                             SampleMetadata.of( this.getEvaluationDescription(),
                                                                                poolSupplier.apply( someStats ) ) );
            return diagrams.stream()
                           .map( innerMapper )
                           .collect( Collectors.toUnmodifiableList() );
        };
    }

    /**
     * Returns a mapper function that maps between raw statistics and wrapped boxplot statistics.
     * 
     * @param supplier the supplier of boxplot statistics
     * @param poolSupplier the pool supplier
     * @return the mapper
     */

    private Function<Statistics, List<BoxplotStatisticOuter>>
            getBoxplotMapper( Function<Statistics, List<BoxplotStatistic>> supplier,
                              Function<Statistics, Pool> poolSupplier )
    {
        return someStats -> {
            List<BoxplotStatistic> boxes = supplier.apply( someStats );
            Function<BoxplotStatistic, BoxplotStatisticOuter> innerMapper =
                    nextBoxplot -> BoxplotStatisticOuter.of( nextBoxplot,
                                                             SampleMetadata.of( this.getEvaluationDescription(),
                                                                                poolSupplier.apply( someStats ) ) );
            return boxes.stream()
                        .map( innerMapper )
                        .collect( Collectors.toUnmodifiableList() );
        };
    }

    /**
     * Returns a mapper function that maps between raw statistics and wrapped double scores.
     * 
     * @param poolSupplier the pool supplier
     * @return the mapper
     */

    private Function<Statistics, List<DoubleScoreStatisticOuter>>
            getDoubleScoreMapper( Function<Statistics, Pool> poolSupplier )
    {
        return someStats -> {
            List<DoubleScoreStatistic> scores = someStats.getScoresList();
            Function<DoubleScoreStatistic, DoubleScoreStatisticOuter> innerMapper =
                    nextScore -> DoubleScoreStatisticOuter.of( nextScore,
                                                               SampleMetadata.of( this.getEvaluationDescription(),
                                                                                  poolSupplier.apply( someStats ) ) );
            return scores.stream()
                         .map( innerMapper )
                         .collect( Collectors.toUnmodifiableList() );
        };
    }

    /**
     * Returns a mapper function that maps between raw statistics and wrapped duration scores.
     * 
     * @param poolSupplier the pool supplier
     * @return the mapper
     */

    private Function<Statistics, List<DurationScoreStatisticOuter>>
            getDurationScoreMapper( Function<Statistics, Pool> poolSupplier )
    {
        return someStats -> {
            List<DurationScoreStatistic> scores = someStats.getDurationScoresList();
            Function<DurationScoreStatistic, DurationScoreStatisticOuter> innerMapper =
                    nextScore -> DurationScoreStatisticOuter.of( nextScore,
                                                                 SampleMetadata.of( this.getEvaluationDescription(),
                                                                                    poolSupplier.apply( someStats ) ) );
            return scores.stream()
                         .map( innerMapper )
                         .collect( Collectors.toUnmodifiableList() );
        };
    }

    /**
     * Returns a mapper function that maps between raw statistics and wrapped duration scores.
     * 
     * @param poolSupplier the pool supplier
     * @return the mapper
     */

    private Function<Statistics, List<DurationDiagramStatisticOuter>>
            getDurationDiagramMapper( Function<Statistics, Pool> poolSupplier )
    {
        return someStats -> {
            List<DurationDiagramStatistic> diagrams = someStats.getDurationDiagramsList();
            Function<DurationDiagramStatistic, DurationDiagramStatisticOuter> innerMapper =
                    nextDiagram -> DurationDiagramStatisticOuter.of( nextDiagram,
                                                                     SampleMetadata.of( this.getEvaluationDescription(),
                                                                                        poolSupplier.apply( someStats ) ) );
            return diagrams.stream()
                           .map( innerMapper )
                           .collect( Collectors.toUnmodifiableList() );
        };
    }

    /**
     * @return the paths to write.
     */

    private List<Supplier<Set<Path>>> getWritersToPaths()
    {
        return Collections.unmodifiableList( this.writersToPaths );
    }

    /**
     * @return paths actually written to by this processor so far.
     */
    @Override
    public Set<Path> get()
    {
        Set<Path> paths = new HashSet<>();

        for ( Supplier<Set<Path>> supplierOfPaths : this.getWritersToPaths() )
        {
            paths.addAll( supplierOfPaths.get() );
        }

        LOGGER.debug( "Returning paths from {} {}: {}", this.getClass().getName(), this, paths );
        return Collections.unmodifiableSet( paths );
    }

    /**
     * <p>Builds a set of consumers for writing based on the project configuration.</p>
     * 
     * <p>Edit this method as new consumer types are supported by the project configuration.</p>
     * 
     * @param sharedWriters an optional set of shared writers
     * @param outputs the description of outputs required
     * @throws ProjectConfigException if the project configuration is invalid for writing
     */

    private void buildConsumers( SharedStatisticsWriters sharedWriters, Outputs outputs )
    {
        // There is one consumer per project for each type, because consumers are built
        // with projects, not destinations. The consumers must iterate destinations.

        // Register consumers for the NetCDF output type
        if ( this.configNeedsThisTypeOfOutput( DestinationType.NETCDF ) )
        {
            // implicitly passing resolvedProject via shared state
            this.buildNetCDFConsumers( sharedWriters );
        }

        // Register consumers for the CSV output type
        if ( this.configNeedsThisTypeOfOutput( DestinationType.CSV ) )
        {
            this.buildCommaSeparatedConsumers();
        }

        // Register consumers for graphics output types, which filters by type already
        this.buildGraphicsConsumers( outputs );

        if ( this.configNeedsThisTypeOfOutput( DestinationType.PROTOBUF ) )
        {
            this.buildMultiStatisticsConsumers( sharedWriters );
        }
    }

    /**
     * Builds a set of consumers for writing files of Comma Separated Values (CSV).
     * Also builds a set of writers to ask for paths written to later.
     * 
     * @throws ProjectConfigException if the project configuration is invalid for writing
     */

    private void buildCommaSeparatedConsumers()
    {
        ProjectConfig projectConfig = this.getProjectConfig();
        Path pathToWrite = this.getOutputDirectory();

        // Build the consumers conditionally
        if ( this.writeWhenTrue.test( StatisticType.DIAGRAM, DestinationType.CSV ) )
        {
            CommaSeparatedDiagramWriter diagramWriter =
                    CommaSeparatedDiagramWriter.of( projectConfig,
                                                    this.getDurationUnits(),
                                                    pathToWrite );
            this.diagramConsumers.put( DestinationType.CSV,
                                       diagramWriter );
            this.writersToPaths.add( diagramWriter );
        }

        if ( this.writeWhenTrue.test( StatisticType.BOXPLOT_PER_PAIR, DestinationType.CSV ) )
        {
            CommaSeparatedBoxPlotWriter boxPlotWriter =
                    CommaSeparatedBoxPlotWriter.of( projectConfig,
                                                    this.getDurationUnits(),
                                                    this.outputDirectory );
            this.boxPlotConsumersPerPair.put( DestinationType.CSV,
                                              boxPlotWriter );
            this.writersToPaths.add( boxPlotWriter );
        }

        if ( this.writeWhenTrue.test( StatisticType.BOXPLOT_PER_POOL, DestinationType.CSV ) )
        {
            CommaSeparatedBoxPlotWriter boxPlotWriter =
                    CommaSeparatedBoxPlotWriter.of( projectConfig,
                                                    this.getDurationUnits(),
                                                    this.outputDirectory );
            this.boxPlotConsumersPerPool.put( DestinationType.CSV,
                                              boxPlotWriter );
            this.writersToPaths.add( boxPlotWriter );
        }

        if ( this.writeWhenTrue.test( StatisticType.DURATION_DIAGRAM, DestinationType.CSV ) )
        {
            // Add the paths for the paired writer: #61841
            CommaSeparatedDurationDiagramWriter pairedWriter =
                    CommaSeparatedDurationDiagramWriter.of( projectConfig,
                                                            this.getDurationUnits(),
                                                            this.outputDirectory );
            this.pairedConsumers.put( DestinationType.CSV, pairedWriter );
            this.writersToPaths.add( pairedWriter );
        }

        if ( this.writeWhenTrue.test( StatisticType.DOUBLE_SCORE, DestinationType.CSV ) )
        {
            // Format
            Format formatter = this.getDecimalFormatter();
            Function<DoubleScoreComponentOuter, String> mapper = next -> {
                if ( Objects.nonNull( formatter ) )
                {
                    return formatter.format( next.getData().getValue() );
                }

                return Double.toString( next.getData().getValue() );
            };

            CommaSeparatedScoreWriter<DoubleScoreComponentOuter, DoubleScoreStatisticOuter> doubleScoreWriter =
                    CommaSeparatedScoreWriter.of( projectConfig,
                                                  this.getDurationUnits(),
                                                  this.outputDirectory,
                                                  mapper );
            this.doubleScoreConsumers.put( DestinationType.CSV,
                                           doubleScoreWriter );
            this.writersToPaths.add( doubleScoreWriter );
        }

        if ( this.writeWhenTrue.test( StatisticType.DURATION_SCORE, DestinationType.CSV ) )
        {
            CommaSeparatedScoreWriter<DurationScoreComponentOuter, DurationScoreStatisticOuter> durationScoreWriter =
                    CommaSeparatedScoreWriter.of( projectConfig,
                                                  this.getDurationUnits(),
                                                  this.outputDirectory,
                                                  next -> MessageFactory.parse( next.getData().getValue() )
                                                                        .toString() );
            this.durationScoreConsumers.put( DestinationType.CSV,
                                             durationScoreWriter );
            this.writersToPaths.add( durationScoreWriter );
        }
    }

    /**
     * Returns a formatter for decimal values as strings, null if none is defined.
     * 
     * @return a formatter or null
     */

    private Format getDecimalFormatter()
    {
        for ( DestinationConfig next : this.getProjectConfig().getOutputs().getDestination() )
        {
            if ( next.getType() == DestinationType.CSV || next.getType() == DestinationType.NUMERIC )
            {
                return ConfigHelper.getDecimalFormatter( next );
            }
        }

        return null;
    }

    /**
     * Builds a set of consumers for writing graphics to destinations.
     *
     * @param outputs the description of outputs required
     * @throws ProjectConfigException if the project configuration is invalid for writing
     */

    private void buildGraphicsConsumers( Outputs outputs )
    {
        ProjectConfig config = this.getProjectConfig();

        Set<DestinationType> types = config.getOutputs()
                                           .getDestination()
                                           .stream()
                                           .map( DestinationConfig::getType )
                                           .filter( ProjectConfigs::isGraphicsType )
                                           .collect( Collectors.toSet() );

        // Add consumers for each type
        for ( DestinationType type : types )
        {
            this.buildGraphicsConsumersForOneFormatType( outputs, type );
        }
    }

    /**
     * Adds a graphic consumer for each type of statistical output and for one format type.
     * @param outputs the description of outputs required
     * @param type the format type
     */

    private void buildGraphicsConsumersForOneFormatType( Outputs outputs, DestinationType type )
    {
        Path pathToWrite = this.getOutputDirectory();

        // Build the consumers conditionally
        if ( this.writeWhenTrue.test( StatisticType.DIAGRAM, type ) )
        {
            DiagramGraphicsWriter diagramWriter = DiagramGraphicsWriter.of( outputs,
                                                                            pathToWrite );
            this.diagramConsumers.put( type,
                                       diagramWriter );
            this.writersToPaths.add( diagramWriter );
        }

        if ( this.writeWhenTrue.test( StatisticType.BOXPLOT_PER_PAIR, type ) )
        {
            BoxPlotGraphicsWriter boxPlotWriter = BoxPlotGraphicsWriter.of( outputs,
                                                                            pathToWrite );
            this.boxPlotConsumersPerPair.put( type,
                                              boxPlotWriter );
            this.writersToPaths.add( boxPlotWriter );
        }

        if ( this.writeWhenTrue.test( StatisticType.BOXPLOT_PER_POOL, type ) )
        {
            BoxPlotGraphicsWriter boxPlotWriter = BoxPlotGraphicsWriter.of( outputs,
                                                                            pathToWrite );
            this.boxPlotConsumersPerPool.put( type,
                                              boxPlotWriter );
            this.writersToPaths.add( boxPlotWriter );
        }

        if ( this.writeWhenTrue.test( StatisticType.DURATION_DIAGRAM, type ) )
        {
            DurationDiagramGraphicsWriter pairedWriter = DurationDiagramGraphicsWriter.of( outputs,
                                                                                           pathToWrite );
            this.pairedConsumers.put( type,
                                      pairedWriter );
            this.writersToPaths.add( pairedWriter );
        }

        if ( this.writeWhenTrue.test( StatisticType.DOUBLE_SCORE, type ) )
        {
            DoubleScoreGraphicsWriter doubleScoreWriter =
                    DoubleScoreGraphicsWriter.of( outputs,
                                                  pathToWrite );
            this.doubleScoreConsumers.put( type,
                                           doubleScoreWriter );
            this.writersToPaths.add( doubleScoreWriter );
        }

        if ( this.writeWhenTrue.test( StatisticType.DURATION_SCORE, type ) )
        {
            DurationScoreGraphicsWriter durationScoreWriter =
                    DurationScoreGraphicsWriter.of( outputs,
                                                    pathToWrite );
            this.durationScoreConsumers.put( type,
                                             durationScoreWriter );
            this.writersToPaths.add( durationScoreWriter );
        }
    }

    /**
     * Builds a set of consumers for writing blobs in netCDF format.
     *
     * @throws ProjectConfigException if the project configuration is invalid for writing
     * @throws IOException if the initial blobs could not be written
     */

    private void buildNetCDFConsumers( SharedStatisticsWriters sharedWriters )
    {
        // Build the consumers conditionally
        if ( Objects.nonNull( sharedWriters )
             && sharedWriters.contains( StatisticType.DOUBLE_SCORE, DestinationType.NETCDF ) )
        {
            LOGGER.debug( "There are shared netcdf consumers for {}", this );

            this.doubleScoreConsumers.put( DestinationType.NETCDF,
                                           next -> sharedWriters.getNetcdfOutputWriter().accept( next ) );
            this.writersToPaths.add( sharedWriters );
            // Not in charge of closing the sharedwriters, that is out at top.
        }
        else
        {
            LOGGER.debug( "There are NOT netcdf consumers for {}", this );
        }
    }

    /**
     * Builds a set of consumers for formats that accept all statistics.
     *
     * @throws ProjectConfigException if the project configuration is invalid for writing
     * @throws IOException if the initial blobs could not be written
     */

    private void buildMultiStatisticsConsumers( SharedStatisticsWriters sharedWriters )
    {
        // Build the consumers conditionally
        if ( Objects.nonNull( sharedWriters ) && sharedWriters.contains( DestinationType.PROTOBUF ) )
        {
            LOGGER.debug( "There are shared protobuf consumers for {}", this );

            this.statisticsConsumers.add( sharedWriters.getProtobufWriter() );
            this.writersToPaths.add( sharedWriters );
            // Not in charge of closing the sharedwriters, that is out at top.
        }
        else
        {
            LOGGER.debug( "There are NOT shared protobuf consumers for {}", this );
        }
    }

    /**
     * Processes {@link DiagramStatisticOuter}.
     * 
     * @param outputs the outputs to consume
     * @throws NullPointerException if the input is null
     */

    private void processDiagramOutputs( List<DiagramStatisticOuter> outputs )
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<List<DiagramStatisticOuter>>> next : this.diagramConsumers.entrySet() )
        {
            // Consume conditionally
            if ( this.writeWhenTrue.test( StatisticType.DIAGRAM, next.getKey() ) )
            {
                log( outputs, next.getKey(), true );

                List<DiagramStatisticOuter> filtered = this.getFilteredStatisticsForThisDestinationType( outputs,
                                                                                                         next.getKey() );

                // Consume the output
                next.getValue().accept( filtered );

                log( outputs, next.getKey(), false );
            }
        }
    }

    /**
     * Processes {@link Statistics} for consumers of all statistics.
     * 
     * @param statistics the statistics to consume
     * @throws NullPointerException if the input is null
     */

    private void processMultiStatistics( Collection<Statistics> statistics )
    {
        Objects.requireNonNull( statistics, NULL_OUTPUT_STRING );

        for ( Statistics nextStatistics : statistics )
        {
            this.statisticsConsumers.forEach( next -> next.accept( nextStatistics ) );
        }
    }

    /**
     * Processes {@link BoxplotStatisticOuter} per pair.
     * 
     * @param outputs the output to consume
     * @throws NullPointerException if the input is null
     */

    private void processBoxPlotOutputsPerPair( List<BoxplotStatisticOuter> outputs )
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<List<BoxplotStatisticOuter>>> next : this.boxPlotConsumersPerPair.entrySet() )
        {
            // Consume conditionally
            if ( this.writeWhenTrue.test( StatisticType.BOXPLOT_PER_PAIR, next.getKey() ) )
            {
                log( outputs, next.getKey(), true );

                List<BoxplotStatisticOuter> filtered = this.getFilteredStatisticsForThisDestinationType( outputs,
                                                                                                         next.getKey() );

                // Consume the output
                next.getValue().accept( filtered );

                log( outputs, next.getKey(), false );
            }
        }
    }

    /**
     * Processes {@link BoxplotStatisticOuter} per pool.
     * 
     * @param outputs the output to consume
     * @throws NullPointerException if the input is null
     */

    private void processBoxPlotOutputsPerPool( List<BoxplotStatisticOuter> outputs )
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<List<BoxplotStatisticOuter>>> next : this.boxPlotConsumersPerPool.entrySet() )
        {
            // Consume conditionally
            if ( this.writeWhenTrue.test( StatisticType.BOXPLOT_PER_POOL, next.getKey() ) )
            {
                log( outputs, next.getKey(), true );

                List<BoxplotStatisticOuter> filtered = this.getFilteredStatisticsForThisDestinationType( outputs,
                                                                                                         next.getKey() );

                // Consume the output
                next.getValue().accept( filtered );

                log( outputs, next.getKey(), false );
            }
        }
    }

    /**
     * Processes {@link DoubleScoreStatisticOuter}.
     * 
     * @param outputs the output to consume
     * @throws NullPointerException if the input is null
     */

    private void processDoubleScoreOutputs( List<DoubleScoreStatisticOuter> outputs )
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<List<DoubleScoreStatisticOuter>>> next : this.doubleScoreConsumers.entrySet() )
        {
            // Consume conditionally
            if ( this.writeWhenTrue.test( StatisticType.DOUBLE_SCORE, next.getKey() ) )
            {
                log( outputs, next.getKey(), true );

                List<DoubleScoreStatisticOuter> filtered = this.getFilteredStatisticsForThisDestinationType( outputs,
                                                                                                             next.getKey() );

                // Consume the output
                next.getValue().accept( filtered );

                log( outputs, next.getKey(), false );
            }
        }

    }

    /**
     * Processes {@link DurationScoreStatisticOuter}.
     * 
     * @param outputs the output to consume
     * @throws NullPointerException if the input is null
     */

    private void processDurationScoreOutputs( List<DurationScoreStatisticOuter> outputs )
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<List<DurationScoreStatisticOuter>>> next : this.durationScoreConsumers.entrySet() )
        {
            // Consume conditionally
            if ( this.writeWhenTrue.test( StatisticType.DURATION_SCORE, next.getKey() ) )
            {
                log( outputs, next.getKey(), true );

                List<DurationScoreStatisticOuter> filtered = this.getFilteredStatisticsForThisDestinationType( outputs,
                                                                                                               next.getKey() );

                // Consume the output
                next.getValue().accept( filtered );

                log( outputs, next.getKey(), false );
            }
        }
    }

    /**
     * Processes {@link DiagramDiagramStatisticOuter}.
     * 
     * @param outputs the output to consume
     * @throws NullPointerException if the input is null
     */

    private void processDurationDiagramStatistic( List<DurationDiagramStatisticOuter> outputs )
    {
        Objects.requireNonNull( outputs, NULL_OUTPUT_STRING );

        // Iterate through the consumers
        for ( Entry<DestinationType, Consumer<List<DurationDiagramStatisticOuter>>> next : this.pairedConsumers.entrySet() )
        {
            // Consume conditionally
            if ( this.writeWhenTrue.test( StatisticType.DURATION_DIAGRAM, next.getKey() ) )
            {
                log( outputs, next.getKey(), true );

                List<DurationDiagramStatisticOuter> filtered =
                        this.getFilteredStatisticsForThisDestinationType( outputs, next.getKey() );

                // Consume the output
                next.getValue().accept( filtered );

                log( outputs, next.getKey(), false );
            }
        }
    }

    /**
     * Returns true if the project configuration has one or more of the given types
     * 
     * @param type the type of output to look for
     * @return true if the output type is present, false otherwise
     */

    private boolean configNeedsThisTypeOfOutput( DestinationType type )
    {
        ProjectConfig projectConfig = this.getProjectConfig();
        wres.config.generated.ProjectConfig.Outputs output = projectConfig.getOutputs();
        if ( Objects.isNull( output ) || output.getDestination().isEmpty() )
        {
            LOGGER.debug( "No destinations specified for config {}", projectConfig );
            return false;
        }

        // Interpret default types for graphic and numeric
        Set<DestinationType> allTypes = new HashSet<>();
        allTypes.add( type );
        if ( type == DestinationType.PNG )
        {
            allTypes.add( DestinationType.GRAPHIC );
        }
        if ( type == DestinationType.CSV )
        {
            allTypes.add( DestinationType.NUMERIC );
        }
        // Return true if any destination types appear in allTypes, otherwise false
        return output.getDestination()
                     .stream()
                     .map( DestinationConfig::getType )
                     .anyMatch( allTypes::contains );
    }


    /**
     * Closes resources that were opened by this class.
     * 
     * @throws IOException if any one consumer could not be closed.
     */

    @Override
    public void close() throws IOException
    {
        int countFailedToClose = 0;
        IOException reThrow = null;
        for ( Closeable resource : this.resourcesToClose )
        {
            LOGGER.debug( "About to close {}", resource );

            try
            {
                resource.close();
            }
            catch ( IOException ioe )
            {
                countFailedToClose++;
                reThrow = ioe;
                // Not much we can do at this point. We tried to close, but
                // we need to try to close all the other resources too before
                // the software exits. Will rethrow the last one below.
                LOGGER.warn( "Unable to close resource {}", resource, ioe );
            }
        }

        // Rethrow
        if ( countFailedToClose > 0 )
        {
            throw new IOException( "While attempting to close a statistics consumer, failed to close "
                                   + countFailedToClose
                                   + " dependent resources. The last exception follows.",
                                   reThrow );
        }
    }


    /**
     * Logs the status of product generation.
     * 
     * @param <T> the output type
     * @param output the output
     * @param type the output type
     * @param startOfProcess is true to log the start, false to log the end
     */

    private <T extends Statistic<?>> void
            log( List<T> output, DestinationType type, boolean startOfProcess )
    {

        String positionString = "Completed ";
        if ( startOfProcess )
        {
            positionString = "Started ";
        }

        if ( !output.isEmpty() )
        {
            LOGGER.debug( "{} processing of result type '{}' for '{}' "
                          + "at time window {}.",
                          positionString,
                          type,
                          output.get( 0 )
                                .getMetadata()
                                .getPool()
                                .getGeometryTuples( 0 )
                                .getLeft()
                                .getName(),
                          output.get( 0 )
                                .getMetadata()
                                .getTimeWindow() );
        }
        else
        {
            LOGGER.debug( "{} processing of result type '{}' for unknown data at "
                          + "unknown time window.",
                          positionString,
                          type );
        }
    }


    /**
     * @return the project config with more (2nd order project config)
     */

    private ProjectConfigPlus getProjectConfigPlus()
    {
        return this.projectConfigPlus;
    }

    /**
     * @return the project config
     */

    private ProjectConfig getProjectConfig()
    {
        return this.getProjectConfigPlus()
                   .getProjectConfig();
    }

    /**
     * @return the duration units
     */

    private ChronoUnit getDurationUnits()
    {
        return this.durationUnits;
    }

    /**
     * Suppress the prescribed output types for the metrics returned.
     * 
     * @param projectConfig the project declaration
     * @param allMetrics the set of all metrics in the project
     * @return the metrics for which particular output types should be suppressed.
     * @throws NullPointerException if the input is null
     */

    private Map<DestinationType, Set<MetricConstants>>
            getMetricsForWhichOutputsShouldBeSuppressed( ProjectConfig projectConfig, Set<MetricConstants> allMetrics )
    {
        Objects.requireNonNull( projectConfig );

        Map<DestinationType, Set<MetricConstants>> returnMe = new EnumMap<>( DestinationType.class );

        // Graphics
        List<DestinationConfig> destinations = projectConfig.getOutputs().getDestination();
        for ( DestinationConfig next : destinations )
        {
            // Graphical types
            GraphicalType graphical = next.getGraphical();
            if ( Objects.nonNull( graphical ) )
            {
                Set<MetricConstants> suppressMe = this.translate( graphical.getSuppressMetric(), allMetrics );
                returnMe.put( next.getType(), suppressMe );
            }
        }

        returnMe = Collections.unmodifiableMap( returnMe );

        if ( LOGGER.isDebugEnabled() && !returnMe.isEmpty() )
        {
            LOGGER.debug( "Discovered a map of destination types for which metrics should be suppressed: {}.",
                          returnMe );
        }

        return returnMe;
    }

    /**
     * Translates a list of {@link MetricConfigName} to a set of {@link MetricConstants}.
     * 
     * @param metrics a list of metrics by declared name
     * @param allMetrics the set of all metrics in the project to use when encountering 
     *            {@link MetricConfigName#ALL_VALID}
     * @return a set of metrics by internal name
     * @throws NullPointerException if any input is null
     */

    private Set<MetricConstants> translate( List<MetricConfigName> metrics, Set<MetricConstants> allMetrics )
    {
        Objects.requireNonNull( metrics );

        Set<MetricConstants> returnMe = new HashSet<>();

        for ( MetricConfigName next : metrics )
        {
            if ( MetricConfigName.ALL_VALID == next )
            {
                return allMetrics;
            }

            MetricConstants add = MetricConstants.valueOf( next.name() );

            returnMe.add( add );
        }

        return Collections.unmodifiableSet( returnMe );
    }

    /**
     * Filters the input statistics for the prescribed destination type relative to the output types that should be 
     * suppressed for particular statistics. See `getSuppressTheseMetricsForThisDestinationType()` down below.
     * 
     * @param statistics the statistics to filter
     * @param destinationType the destination type by which to filter
     * @return a filtered list of statistics, omitting those to be suppressed for the prescribed destination type
     * @throws NullPointerException if any input is null
     */

    private <T extends Statistic<?>> List<T>
            getFilteredStatisticsForThisDestinationType( List<T> statistics, DestinationType destinationType )
    {
        Objects.requireNonNull( statistics );

        Objects.requireNonNull( destinationType );

        Set<MetricConstants> suppress = this.getSuppressTheseMetricsForThisDestinationType( destinationType );

        // Filter suppressed types
        if ( Objects.nonNull( suppress ) )
        {
            return Slicer.filter( statistics, next -> !suppress.contains( next.getMetricName() ) );
        }

        // Nothing filtered
        return statistics;
    }

    /**
     * Returns the metrics that should be suppressed for the prescribed destination.
     * 
     * @return the map of destination types to statistics for suppression
     */

    private Set<MetricConstants> getSuppressTheseMetricsForThisDestinationType( DestinationType destinationType )
    {
        return this.suppressTheseDestinationsForTheseMetrics.get( destinationType );
    }

    /**
     * @return the evaluation description.
     */

    private Evaluation getEvaluationDescription()
    {
        return this.evaluationDescription;
    }

    /**
     * @return the output directory.
     */

    private Path getOutputDirectory()
    {
        return this.outputDirectory;
    }

    /**
     * Build a product processor that writes conditionally.
     * 
     * @param evaluationDescription the evaluation description
     * @param projectConfigPlus the wrapped project declaration
     * @param writeWhenTrue the condition under which outputs should be written
     * @param sharedWriters an optional set of shared writers to consume outputs
     * @param outputDirectory the output directory
     * @throws NullPointerException if any of the inputs are null
     * @throws WresProcessingException if the project is invalid for writing
     */

    private StatisticsConsumer( Evaluation evaluationDescription,
                                ProjectConfigPlus projectConfigPlus,
                                BiPredicate<StatisticType, DestinationType> writeWhenTrue,
                                SharedStatisticsWriters sharedWriters,
                                Path outputDirectory )
    {
        Objects.requireNonNull( projectConfigPlus,
                                "Specify a non-null configuration for the results processor." );
        Objects.requireNonNull( writeWhenTrue, "Specify a non-null condition to ignore." );
        Objects.requireNonNull( evaluationDescription );
        Objects.requireNonNull( outputDirectory );

        this.resourcesToClose = new ArrayList<>( 1 );
        this.writersToPaths = new ArrayList<>();
        this.projectConfigPlus = projectConfigPlus;
        this.writeWhenTrue = writeWhenTrue;
        this.evaluationDescription = evaluationDescription;
        this.outputDirectory = outputDirectory;

        ProjectConfig projectConfig = projectConfigPlus.getProjectConfig();

        // Could also be supplied on construction, but overhead is not too large
        Set<MetricConstants> metrics = MetricConfigHelper.getMetricsFromConfig( projectConfig );

        this.suppressTheseDestinationsForTheseMetrics =
                this.getMetricsForWhichOutputsShouldBeSuppressed( projectConfig, metrics );

        // Register the duration units
        String durationUnitsString = projectConfig.getOutputs()
                                                  .getDurationFormat()
                                                  .value()
                                                  .toUpperCase();

        this.durationUnits = ChronoUnit.valueOf( durationUnitsString );

        // Register output consumers
        try
        {
            // implicitly passing resolvedProject via shared state
            this.buildConsumers( sharedWriters, evaluationDescription.getOutputs() );
        }
        catch ( ProjectConfigException e )
        {
            throw new WresProcessingException( "While processing the project configuration to write output:", e );
        }
    }

}
