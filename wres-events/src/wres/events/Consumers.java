package wres.events;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import net.jcip.annotations.Immutable;
import wres.statistics.generated.EvaluationStatus;
import wres.statistics.generated.Pairs;
import wres.statistics.generated.Statistics;
import wres.statistics.generated.Consumer.Format;
import wres.statistics.generated.Evaluation;

/**
 * Bag of consumers to consume the messages associated with one evaluation. External subscribers are not represented 
 * here, as they are negotiated between the core client and one or more subscriber clients at runtime.
 * 
 * @author james.brown@hydrosolved.com
 */

@Immutable
public class Consumers
{

    private static final Logger LOGGER = LoggerFactory.getLogger( Consumers.class );

    /**
     * Consumers of evaluation events, which contain descriptions of evaluations to conduct.
     */

    private final List<Function<Evaluation, Set<Path>>> evaluationConsumers;

    /**
     * Consumers of evaluation status events, which contain information about the status of an evaluation and 
     * associated user-facing messages (as distinct from developer-facing, which are logged).
     */

    private final List<Function<EvaluationStatus, Set<Path>>> statusConsumers;

    /**
     * Consumers of evaluation statistics.
     */

    private final List<Function<Statistics, Set<Path>>> statisticsConsumers;

    /**
     * The union of all output format types that are generated by the statistics consumers. If any types that are 
     * required by an evaluation are missing, then these must be delivered by one or more external subscribers.
     */

    private final Set<Format> statisticsConsumerTypes;

    /**
     * Consumers of groups of evaluation statistics where consumption is triggered by group.
     */

    private final List<Function<Collection<Statistics>, Set<Path>>> groupedStatisticsConsumers;

    /**
     * Consumers of pairs.
     */

    private final List<Function<Pairs, Set<Path>>> pairsConsumers;

    /**
     * @return the evaluation consumers
     */
    List<Function<Evaluation, Set<Path>>> getEvaluationConsumers()
    {
        return this.evaluationConsumers; //Immutable on construction
    }

    /**
     * @return the evaluation status consumers
     */
    List<Function<EvaluationStatus, Set<Path>>> getEvaluationStatusConsumers()
    {
        return this.statusConsumers; //Immutable on construction
    }

    /**
     * @return the statistics consumers
     */
    List<Function<Statistics, Set<Path>>> getStatisticsConsumers()
    {
        return this.statisticsConsumers; //Immutable on construction
    }

    /**
     * @return the consumers of statistics groups
     */
    List<Function<Collection<Statistics>, Set<Path>>> getGroupedStatisticsConsumers()
    {
        return this.groupedStatisticsConsumers; //Immutable on construction
    }

    /**
     * @return the consumers of pairs
     */
    List<Function<Pairs, Set<Path>>> getPairsConsumers()
    {
        return this.pairsConsumers; //Immutable on construction
    }

    /**
     * @return the format types negotiated by statistics consumers
     */
    Set<Format> getStatisticsConsumerTypes()
    {
        return this.statisticsConsumerTypes; //Immutable on construction
    }

    /**
     * Builder.
     */

    public static class Builder
    {

        /**
         * Consumers of evaluation events, which contain descriptions of evaluations to conduct.
         */

        private List<Function<Evaluation, Set<Path>>> evaluationConsumers = new ArrayList<>();

        /**
         * Consumers of evaluation status events, which contain information about the status of an evaluation and 
         * associated user-facing messages (as distinct from developer-facing, which are logged).
         */

        private List<Function<EvaluationStatus, Set<Path>>> statusConsumers = new ArrayList<>();

        /**
         * Consumers of evaluation statistics.
         */

        private List<Function<Statistics, Set<Path>>> statisticsConsumers = new ArrayList<>();

        /**
         * Union of format types handled by the statistics consumers.
         */

        private Set<Format> statisticsConsumerTypes = new HashSet<>();

        /**
         * Consumers of groups of evaluation statistics.
         */

        private List<Function<Collection<Statistics>, Set<Path>>> groupedStatisticsConsumers = new ArrayList<>();

        /**
         * Consumers of pairs.
         */

        private List<Function<Pairs, Set<Path>>> pairsConsumers = new ArrayList<>();

        /**
         * @param evaluationConsumer the evaluation consumer to add
         * @return this builder
         * @throws NullPointerException if the input is null
         */

        public Builder addEvaluationConsumer( Function<Evaluation, Set<Path>> evaluationConsumer )
        {
            Objects.requireNonNull( evaluationConsumer );

            this.evaluationConsumers.add( evaluationConsumer );

            return this;
        }

        /**
         * @param statusConsumer the status consumer to add
         * @return this builder
         * @throws NullPointerException if the input is null
         */

        public Builder addStatusConsumer( Function<EvaluationStatus, Set<Path>> statusConsumer )
        {
            Objects.requireNonNull( statusConsumer );

            this.statusConsumers.add( statusConsumer );

            return this;
        }

        /**
         * @param statisticsConsumer the statistics consumer to add
         * @param format one or more format types negotiated by the consumer
         * @return this builder
         * @throws NullPointerException if the consumer is null
         * @throws IllegalArgumentException if there are zero formats
         */

        public Builder addStatisticsConsumer( Function<Statistics, Set<Path>> statisticsConsumer, Format... format )
        {
            Objects.requireNonNull( statisticsConsumer );

            if ( format.length == 0 )
            {
                throw new IllegalArgumentException( "Specify one or more format types handled by the consumer." );
            }

            this.statisticsConsumers.add( statisticsConsumer );
            this.statisticsConsumerTypes.addAll( Arrays.asList( format ) );

            return this;
        }

        /**
         * @param groupStatisticsConsumer the consumer for groups of evaluation events
         * @param format one or more format types negotiated by the consumer
         * @return this builder
         * @throws NullPointerException if the input is null
         * @throws IllegalArgumentException if there are zero formats
         */

        public Builder
                addGroupedStatisticsConsumer( Function<Collection<Statistics>, Set<Path>> groupStatisticsConsumer,
                                              Format... format )
        {
            Objects.requireNonNull( groupStatisticsConsumer );

            if ( format.length == 0 )
            {
                throw new IllegalArgumentException( "Specify one or more format types handled by the consumer." );
            }

            this.groupedStatisticsConsumers.add( groupStatisticsConsumer );
            this.statisticsConsumerTypes.addAll( Arrays.asList( format ) );

            return this;
        }

        /**
         * @param pairsConsumer the pairs consumer to add
         * @return this builder
         */

        public Builder addPairsConsumer( Function<Pairs, Set<Path>> pairsConsumer )
        {
            if ( Objects.nonNull( pairsConsumer ) )
            {
                this.pairsConsumers.add( pairsConsumer );
            }

            return this;
        }

        /**
         * Builds a consumer group.
         * 
         * @return a consumer group
         */

        public Consumers build()
        {
            return new Consumers( this );
        }
    }

    /**
     * Hidden constructor.
     * 
     * @param builder the builder
     */
    private Consumers( Builder builder )
    {
        this.evaluationConsumers = Collections.unmodifiableList( builder.evaluationConsumers );
        this.statisticsConsumers = Collections.unmodifiableList( builder.statisticsConsumers );
        this.statusConsumers = Collections.unmodifiableList( builder.statusConsumers );
        this.groupedStatisticsConsumers = Collections.unmodifiableList( builder.groupedStatisticsConsumers );
        this.pairsConsumers = Collections.unmodifiableList( builder.pairsConsumers );
        this.statisticsConsumerTypes = Collections.unmodifiableSet( builder.statisticsConsumerTypes );

        LOGGER.debug( "Successfully constructed a consumer group with {} evaluation consumers, {} evaluation status "
                      + "consumers, {} statistics consumers, {} and pairs consumers. The statistics consumers "
                      + "negotiate the format types {}.",
                      this.getEvaluationConsumers().size(),
                      this.getEvaluationStatusConsumers().size(),
                      this.getStatisticsConsumers().size(),
                      this.getPairsConsumers().size(),
                      this.getStatisticsConsumerTypes() );
    }

}
